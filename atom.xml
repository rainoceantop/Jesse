<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jesse</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/Jesse/atom.xml" rel="self"/>
  
  <link href="https://rainoceantop.github.io/Jesse/"/>
  <updated>2018-07-24T00:33:45.177Z</updated>
  <id>https://rainoceantop.github.io/Jesse/</id>
  
  <author>
    <name>Jesse</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NoSQL非关系型数据库redis笔记</title>
    <link href="https://rainoceantop.github.io/Jesse/2018/07/24/NoSQL%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93redis%E7%AC%94%E8%AE%B0/"/>
    <id>https://rainoceantop.github.io/Jesse/2018/07/24/NoSQL非关系型数据库redis笔记/</id>
    <published>2018-07-23T22:45:45.000Z</published>
    <updated>2018-07-24T00:33:45.177Z</updated>
    
    <content type="html"><![CDATA[<p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><a id="more"></a><h4 id="安装向导"><a href="#安装向导" class="headerlink" title="安装向导"></a>安装向导</h4><p>linux安装：<code>sudo pacman -S redis (manjaro)</code> | <code>sudo apt-get install redis-server (ubuntu)</code><br>运行客户端：<code>redis-cli</code><br>遇到<code>Could not connect to Redis at 127.0.0.1:6379: Connection refused</code>问题：<br>1.如果/etc目录下没有redis.conf，将redis.conf复制到/etc目录下<br>2.打开redis.conf，将<strong>daemonize</strong>的值no改为yes，默认启动后台运行<br>3.开启<code>sudo redis-server /etc/redis.conf</code>服务端<br>4.重新运行redis客户端 <code>redis-cli</code>，输入ping，如果返回pong说明运行成功<br><strong>注：redis关键字不区分大小写，本笔记为了防止混淆，所有redis字段用大写</strong></p><hr><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>set | get：设置|获取 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET foo 100</span><br><span class="line">SET foo &quot;hello&quot; EX 10  ：10秒过期</span><br><span class="line">SET foo &quot;hello&quot; PX 1000：1000毫秒或1秒过期</span><br><span class="line">SET foo &quot;hello&quot; NX     ：只有foo键不存在值时才操作</span><br><span class="line">SET foo &quot;hello&quot; XX     ：只有foo键存在值时才操作</span><br><span class="line">GET foo</span><br></pre></td></tr></table></figure></p><p>mset | mget：设置|获取 多个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MSET foo &quot;hello&quot; bar &quot;world&quot;</span><br><span class="line">MGET foo bar</span><br></pre></td></tr></table></figure></p><p>strlen：返回对象字符串值的长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN foo</span><br></pre></td></tr></table></figure></p><p>append：给对象字符串追加值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND foo &quot; world&quot;</span><br></pre></td></tr></table></figure></p><p>rename：修改key的名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME foo bar</span><br></pre></td></tr></table></figure></p><p>del：删除对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL foo</span><br></pre></td></tr></table></figure></p><p>expire：设置过期<strong>秒数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE foo 10</span><br></pre></td></tr></table></figure></p><p>pexpire：设置过期<strong>毫秒数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PEXPIRE foo 1000</span><br></pre></td></tr></table></figure></p><p>expireat：设置过期<strong>时间戳</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIREAT foo timestamp_val</span><br></pre></td></tr></table></figure></p><p>ttl：查看剩余<strong>秒数</strong>过期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTL foo</span><br></pre></td></tr></table></figure></p><p>pttl：查看剩余<strong>毫秒数</strong>过期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTTL foo</span><br></pre></td></tr></table></figure></p><p>persist：移除过期时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PERSIST foo</span><br></pre></td></tr></table></figure></p><p>incr | decr：数字自增|自减 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCR foo</span><br><span class="line">DECR foo</span><br></pre></td></tr></table></figure></p><p>exists：查看对象是否存在，可同时查看多个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXISTS foo</span><br><span class="line">EXISTS foo bar</span><br></pre></td></tr></table></figure></p><h4 id="LIST列表"><a href="#LIST列表" class="headerlink" title="LIST列表"></a>LIST列表</h4><p>lpush | rpush：将元素 左推|右推 进列表，列表不存在则创建新列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUSH mylist &quot;hello&quot; </span><br><span class="line">RPUSH mylist &quot;world&quot;</span><br><span class="line">RPUSH mylist &quot;hello&quot; &quot;world&quot;</span><br></pre></td></tr></table></figure></p><p>lpushx | rpushx：将元素 左推|右推 进列表，列表不存在则操作失败<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX mylist &quot;hello&quot; </span><br><span class="line">RPUSHX mylist &quot;world&quot;</span><br></pre></td></tr></table></figure></p><p>lrange：获取列表元素值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE mylist 0 -1</span><br></pre></td></tr></table></figure></p><p>llen：获取列表长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN mylist</span><br></pre></td></tr></table></figure></p><p>lpop | rpop： 左弹出|右弹出列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP mylist</span><br><span class="line">RPOP mylist</span><br></pre></td></tr></table></figure></p><p>rpoplpush：从列表中右弹出一个元素，将弹出的元素左插入到另外一个列表中并返回它；如果列表没有元素返回nil<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH mylist1 mylist2</span><br></pre></td></tr></table></figure></p><p>linsert：插入元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LINSERT mylist BEFORE &quot;world&quot; &quot;insert text1&quot;</span><br><span class="line">LINSERT mylist AFTER &quot;hello&quot; &quot;insert text2&quot;</span><br></pre></td></tr></table></figure></p><p>lindex：返回列表中该索引的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINDEX mylist 0</span><br></pre></td></tr></table></figure></p><p>blpop | brpop：移出并获取列表的第一|最后个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BLPOP mylist 10</span><br><span class="line">BRPOP mylist 10</span><br></pre></td></tr></table></figure></p><p>brpoplpush：从列表中右弹出一个元素，将弹出的元素左插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOPLPUSH mylist1 mylist2</span><br></pre></td></tr></table></figure></p><p>lrem：根据参数 count的值，移除列表中与参数 value相等的元素<br>    语法 ：  lrem key count value<br>    count &gt; 0 ： 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT<br>    count &lt; 0 ： 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值<br>    count = 0 ： 移除表中所有与 VALUE 相等的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM mylist 1 &apos;foo&apos;</span><br></pre></td></tr></table></figure></p><p>lset：通过索引设置元素的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSET mylist 0 &apos;new one&apos;</span><br></pre></td></tr></table></figure></p><p>ltrim：设置区间裁剪列表，区间外元素全部丢弃<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRIM mylist 0 5</span><br></pre></td></tr></table></figure></p><h4 id="SET集合"><a href="#SET集合" class="headerlink" title="SET集合"></a>SET集合</h4><p>sadd：将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD people &quot;nancy&quot; &quot;mike&quot; &quot;kevin&quot; &quot;david&quot;</span><br></pre></td></tr></table></figure></p><p>scard：返回集合中元素的数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD people</span><br></pre></td></tr></table></figure></p><p>sdiff：返回与第一个给定集合的差集。不存在的集合 key 将视为空集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFF people people2</span><br></pre></td></tr></table></figure></p><p>sdiffstore：将与第一个给定集合的差集存储在给指定集合中，如果指定集合已存在则会被覆盖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE people3 people people2</span><br></pre></td></tr></table></figure></p><p>sinter：返回给定所有给定集合的交集。不存在的集合 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER people people2</span><br></pre></td></tr></table></figure></p><p>sinterstore：将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE people4 people people2</span><br></pre></td></tr></table></figure></p><p>sismember：判断成员元素是否是集合的成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER people &quot;nancy&quot;</span><br></pre></td></tr></table></figure></p><p>smembers：返回集合中所有的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS people</span><br></pre></td></tr></table></figure></p><p>smove：将指定成员 member 元素从 source 集合移动到 destination 集合<br>    SMOVE 是原子性操作<br>    如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去<br>    当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除<br>    当 source 或 destination 不是集合类型时，返回一个错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMOVE people people2 &quot;mike&quot;</span><br></pre></td></tr></table></figure></p><p>spop：移除并返回集合中的一个随机元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP people</span><br></pre></td></tr></table></figure></p><p>srandmember：返回随机元素<br>    语法：srandmember myset [count]<br>    如果 count 为正数，且小于集合基数，那么命令返回一个包含 count个元素的数组，数组中的元素各不相同。如果 count大于等于集合基数，那么返回整个集合<br>    如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count的绝对值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER people -3</span><br></pre></td></tr></table></figure></p><p>srem：移除集合中的一个或多个成员元素，不存在的成员元素会被忽略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM people &quot;kevin&quot; &quot;david&quot;</span><br></pre></td></tr></table></figure></p><p>sunion：返回给定集合的并集。不存在的集合 key 被视为空集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNION people people2 people3 people4</span><br></pre></td></tr></table></figure></p><p>sunionstore：将给定集合的并集存储在指定的集合 destination 中。如果 destination 已经存在，则将其覆盖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNIONSTORE people5 people people2 people3 people4</span><br></pre></td></tr></table></figure></p><p>sscan：用于迭代集合中键的元素，返回迭代后当前指针位置以及找到的元素<br>    语法：SSCAN key cursor [MATCH pattern] [COUNT count]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSCAN people 0 MATCH *i* COUNT 10</span><br></pre></td></tr></table></figure></p><h4 id="SET有序集合"><a href="#SET有序集合" class="headerlink" title="SET有序集合"></a>SET有序集合</h4><p>zadd：将一个或多个成员元素及其分数值加入到有序集当中<br>    语法：ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN<br>    如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上<br>    分数值可以是整数值或双精度浮点数<br>    如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作<br>    当 key 存在但不是有序集类型时，返回一个错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD users 1995 &quot;david&quot; 1996 &quot;mike&quot; 1997 &quot;nancy&quot; 1998 &quot;andy&quot; 1999 &quot;aaron&quot;</span><br></pre></td></tr></table></figure></p><p>zcard：计算集合中元素的数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD users</span><br></pre></td></tr></table></figure></p><p>zcount：计算有序集合中指定分数区间的成员数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT users 1996 1998</span><br></pre></td></tr></table></figure></p><p>zincrby：对有序集合中指定成员的分数加上增量，可负数。当集合不存在则创建新有序集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY users -5 &quot;andy&quot;</span><br></pre></td></tr></table></figure></p><p>zinterstore：计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination<br>    语法：ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]<br>    参数WEIGHTS：将分数以倍数相乘<br>    参数AGGREGATE：以哪种方式进行分数计算，sum相加，min最小，max最大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE users3 2 users users2 WEIGHTS 2 3 AGGREGATE MAX</span><br></pre></td></tr></table></figure></p><p>zrange：返回有序集中，指定区间内的成员。其中成员的位置按分数值递增(从小到大)来排序。返回分数最后加withscores<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE users 0 -1 WITHSCORES</span><br></pre></td></tr></table></figure></p><p>zrevrange：返回有序集中，指定区间内的成员。其中成员的位置按分数值递减(从大到小)来排列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE users 0 -1 WITHSCORES</span><br></pre></td></tr></table></figure></p><p>zrangebyscore：返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。<br>    默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE users 1996 (1999</span><br></pre></td></tr></table></figure></p><p>zrank：返回有序集中指定成员的排名。排名数字越小分数越大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANK users andy</span><br></pre></td></tr></table></figure></p><p>zrevrank：返回有序集中指定成员的排名。排名数字越大分数越大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANK users andy</span><br></pre></td></tr></table></figure></p><p>zrem：移除有序集中的一个或多个成员，不存在的成员将被忽略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM mike andy aaron</span><br></pre></td></tr></table></figure></p><p>zremrangebyrank：移除有序集中，指定排名(rank)区间内的所有成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYRANK users 2 3</span><br></pre></td></tr></table></figure></p><p>zremrangebyscore：移除有序集中，指定分数（score）区间内的所有成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE users 1996 1998</span><br></pre></td></tr></table></figure></p><p>zscore：返回有序集中，成员的分数值。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 nil<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE users aaron</span><br></pre></td></tr></table></figure></p><p>zunionstore：算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination<br>    语法和参数与zinterstore一致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE users3 2 users users2 WEIGHTS 2 3 AGGREGATE MAX</span><br></pre></td></tr></table></figure></p><p>zscan：用于迭代有序集合中的元素（包括元素成员和元素分值）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCAN users 0 MATCH *a*</span><br></pre></td></tr></table></figure></p><h4 id="HSET哈希表"><a href="#HSET哈希表" class="headerlink" title="HSET哈希表"></a>HSET哈希表</h4><p>hset：为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，旧值将被覆盖。<br>hget：返回哈希表中指定字段的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HSET website google &quot;google.com&quot;</span><br><span class="line">HGET website google</span><br></pre></td></tr></table></figure></p><p>hmset：同时将多个 field-value(字段-值)对设置到哈希表中。此命令会覆盖哈希表中已存在的字段。如果哈希表不存在，会创建一个空哈希表，并执行 HMSET操作<br>hmget：返回哈希表中，一个或多个给定字段的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HMSET website baidu &quot;baidu.com&quot; huawei &quot;huawei.com&quot; facebook &quot;facebook.com&quot; visitor 2000125</span><br><span class="line">HMGET website baidu huawei facebook</span><br></pre></td></tr></table></figure></p><p>hlen：获取哈希表中字段的数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN website</span><br></pre></td></tr></table></figure></p><p>hkeys：获取哈希表中的所有域（field）<br>hvals：获取哈希表中所有值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEYS website</span><br><span class="line">HVALS website</span><br></pre></td></tr></table></figure></p><p>hgetall：获取在哈希表中指定 key 的所有字段和值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGETALL website</span><br></pre></td></tr></table></figure></p><p>hexists：查看哈希表的指定字段是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS website google</span><br></pre></td></tr></table></figure></p><p>hdel：删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL website baidu facebook</span><br></pre></td></tr></table></figure></p><p>hincrby：用于为哈希表中的字段值加上指定增量值<br>    增量也可以为负数，相当于对指定字段进行减法操作<br>    如果哈希表的 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令<br>    如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0<br>    对一个储存字符串值的字段执行 HINCRBY 命令将造成一个错误<br>    本操作的值被限制在 64 位(bit)有符号数字表示之内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY website visitor 100</span><br></pre></td></tr></table></figure></p><p>hincrbyfloat:为哈希表中的字段值加上指定浮点数增量值。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBYFLOAT website mark 9.8</span><br></pre></td></tr></table></figure></p><p>hsetnx：为哈希表中不存在的的字段赋值，如果字段已经存在于哈希表中，操作无效。如果哈希表不存在则创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX website google &quot;hello world&quot;</span><br></pre></td></tr></table></figure></p><p>hscan：迭代哈希表中的键值对<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSCAN website 0 MATCH *o*</span><br></pre></td></tr></table></figure></p><h4 id="HYPERLOGLOG基数统计"><a href="#HYPERLOGLOG基数统计" class="headerlink" title="HYPERLOGLOG基数统计"></a>HYPERLOGLOG基数统计</h4><p><strong>用途</strong><br>用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的<br>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比<br>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素</p><p>pfadd：添加指定元素（一或多）到 HyperLogLog 中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PFADD nosqls redis memcached mongodb</span><br><span class="line">PFADD sqls mysql sqlserver</span><br></pre></td></tr></table></figure></p><p>pfcount：返回给定 HyperLogLog 的基数估算值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT nosqls</span><br></pre></td></tr></table></figure></p><p>pfmerge：将多个 HyperLogLog 合并为一个 HyperLogLog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFMERGE dbs nosqls sqls</span><br></pre></td></tr></table></figure></p><h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><p>subscribe：订阅给定的一个或多个频道的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE redisroom</span><br></pre></td></tr></table></figure></p><p>unsubscribe：退订给定的一个或多个频道的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNSUBSCRIBE redisroom</span><br></pre></td></tr></table></figure></p><p>psubscribe：订阅一个或多个符合给定模式的频道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSUBSCRIBE *chat</span><br></pre></td></tr></table></figure></p><p>punsubscribe：退订所有给定模式的频道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUNSUBSCRIBE  *chat</span><br></pre></td></tr></table></figure></p><p>publish：将信息发送到指定的频道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH redisroom &quot;hello there&quot;</span><br></pre></td></tr></table></figure></p><p>pubsub：查看订阅与发布系统状态，三个参数可选CHANNELS，NUMSUB，NUMPAT<br>    参数channels：返回当前活跃的频道，可指定pattern<br>    参数numsub  ：返回指定频道的订阅数，不包含模式订阅数<br>    参数numpat  ：返回通过模式订阅的频道数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUBSUB CHANNELS *room</span><br><span class="line">PUBSUB NUMSUB redisroom</span><br><span class="line">PUBSUB NUMPAT</span><br></pre></td></tr></table></figure></p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p><strong>介绍</strong><br>开启事务可以一次执行多个命令<br>并且带有以下重要的保证<br>        批量操作在发送 EXEC 命令前被放入队列缓存<br>        收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行<br>        在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中<br>一个事务从开始到执行会经历三个阶段：开始事务、命令入队、执行事务</p><p>multi：标记一个事务块的开始<br>discard：取消事务，放弃执行事务块内的所有命令<br>exec：执行所有事务块内的命令<br>watch：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断<br>unwatch：取消 WATCH 命令对所有 key 的监视<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set a aaa</span><br><span class="line">watch a</span><br><span class="line">#unwatch（执行这个取消a监视）</span><br><span class="line">append a bbb （修改a的值）</span><br><span class="line">multi（开始事物）</span><br><span class="line">set b bbb</span><br><span class="line">#discard（执行这个取消事务）</span><br><span class="line">exec（返回nil，被打断，因为事务前a被修改）</span><br></pre></td></tr></table></figure></p><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><h5 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h5><p><em>可以通过 redis 的配置文件（redis.conf）或使用命令设置密码，这样客户端连接到 redis 服务就需要密码验证</em><br>配置文件redis.conf：找到requirepass那行，将前面的注释去掉并修改密码，重启服务<br>使用命令设置（重启无效，除非配置文件已经设置）：<code>config set requirepass this_is_a_password</code><br>使用命令清除：<code>config set requirepass &quot;&quot;</code><br>使用密码：<code>auth this_is_a_password</code></p><h5 id="数据备份与恢复"><a href="#数据备份与恢复" class="headerlink" title="数据备份与恢复"></a>数据备份与恢复</h5><p><code>save</code>：在 redis安装目录中(/var/lib/redis)创建dump.rdb文件<br><code>bgsave</code>：在后台执行备份<br><code>config get dir</code>：获取redis安装目录<br>恢复数据只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</p><h4 id="redis服务器命令"><a href="#redis服务器命令" class="headerlink" title="redis服务器命令"></a>redis服务器命令</h4><p><code>SELECT [num]</code>：切换数据库，默认数据库是0<br><code>BGREWRITEAOF</code>：异步执行一个 AOF（AppendOnly File） 文件重写操作<br><code>BGSAVE</code>：在后台异步保存当前数据库的数据到磁盘<br><code>CLIENT KILL [ip:port] [ID client-id]</code>：关闭客户端连接<br><code>CLIENT LIST</code>：获取连接到服务器的客户端连接列表<br><code>CLIENT GETNAME</code>：获取连接的名称<br><code>CLIENT PAUSE timeout</code>：在指定时间内终止运行来自客户端的命令<br><code>CLIENT SETNAME connection-name</code>：设置当前连接的名称<br><code>CLUSTER SLOTS</code>：获取集群节点的映射数组<br><code>COMMAND</code>：获取 Redis 命令详情数组<br><code>COMMAND COUNT</code>：获取 Redis 命令总数<br><code>COMMAND GETKEYS</code>：获取给定命令的所有键<br><code>TIME</code>：返回当前服务器时间<br><code>COMMAND INFO command-name [command-name ...]</code>：获取指定 Redis 命令描述的数组<br><code>CONFIG GET parameter</code>：获取指定配置参数的值<br><code>CONFIG REWRITE</code>：对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写<br><code>CONFIG SET parameter value</code>：修改 redis 配置参数，无需重启<br><code>CONFIG RESETSTAT</code>：重置 INFO 命令中的某些统计数据<br><code>DBSIZE</code>：返回当前数据库的 key 的数量<br><code>DEBUG OBJECT key</code>：获取 key 的调试信息<br><code>DEBUG SEGFAULT</code>：让 Redis 服务崩溃<br><code>FLUSHALL</code>：删除所有数据库的所有key<br><code>FLUSHDB</code>：删除当前数据库的所有key<br><code>INFO [section]</code>：获取 Redis 服务器的各种信息和统计数值<br><code>LASTSAVE</code>：返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示<br><code>MONITOR</code>：实时打印出 Redis 服务器接收到的命令，调试用<br><code>ROLE</code>：返回主从实例所属的角色<br><code>SAVE</code>：同步保存数据到硬盘<br><code>SHUTDOWN [NOSAVE] [SAVE]</code>：异步保存数据到硬盘，并关闭服务器<br><code>SLAVEOF host port</code>：将当前服务器转变为指定服务器的从属服务器(slave server)<br><code>SLOWLOG subcommand [argument]</code>：管理 redis 的慢日志<br><code>SYNC</code>：用于复制功能(replication)的内部命令</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。&lt;/p&gt;
    
    </summary>
    
      <category term="NoSQL" scheme="https://rainoceantop.github.io/Jesse/categories/NoSQL/"/>
    
      <category term="redis" scheme="https://rainoceantop.github.io/Jesse/categories/NoSQL/redis/"/>
    
    
      <category term="缓存技术" scheme="https://rainoceantop.github.io/Jesse/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
      <category term="缓存" scheme="https://rainoceantop.github.io/Jesse/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="nosql" scheme="https://rainoceantop.github.io/Jesse/tags/nosql/"/>
    
      <category term="redis" scheme="https://rainoceantop.github.io/Jesse/tags/redis/"/>
    
      <category term="非关系型数据库" scheme="https://rainoceantop.github.io/Jesse/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>php魔法方法</title>
    <link href="https://rainoceantop.github.io/Jesse/2018/07/23/php%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>https://rainoceantop.github.io/Jesse/2018/07/23/php魔法方法/</id>
    <published>2018-07-22T23:38:32.000Z</published>
    <updated>2018-07-22T23:47:58.361Z</updated>
    
    <content type="html"><![CDATA[<p>本文列出php魔法方法什么情况下被调用（未完带续）</p><a id="more"></a><h4 id="construct：被实例化时调用"><a href="#construct：被实例化时调用" class="headerlink" title="construct：被实例化时调用"></a>construct：被实例化时调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function __construct()&#123;</span><br><span class="line">    echo &quot;被实例...&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="destruct：主动调用或者脚本结束或者使用exit-时调用"><a href="#destruct：主动调用或者脚本结束或者使用exit-时调用" class="headerlink" title="destruct：主动调用或者脚本结束或者使用exit()时调用"></a>destruct：主动调用或者脚本结束或者使用exit()时调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function __destruct()&#123;</span><br><span class="line">    echo &quot;被释放...&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="call：调用一个不可访问或不存在的方法时被调用"><a href="#call：调用一个不可访问或不存在的方法时被调用" class="headerlink" title="call：调用一个不可访问或不存在的方法时被调用"></a>call：调用一个不可访问或不存在的方法时被调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function __call($name, $arguments)&#123;</span><br><span class="line">    echo &quot;调用了一个不可访问的方法&quot;.$name.&quot;，参数：&quot;.implode(&quot;,&quot;,$arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="callStatic：调用一个不可访问或不存在的静态方法时被调用"><a href="#callStatic：调用一个不可访问或不存在的静态方法时被调用" class="headerlink" title="callStatic：调用一个不可访问或不存在的静态方法时被调用"></a>callStatic：调用一个不可访问或不存在的静态方法时被调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static function __callStatic($name, $arguments)&#123;</span><br><span class="line">    echo &quot;调用了一个不可访问的静态方法&quot;.$name.&quot;，参数：&quot;.implode(&quot;,&quot;,$arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get：读取不可访问或不存在的属性时调用"><a href="#get：读取不可访问或不存在的属性时调用" class="headerlink" title="get：读取不可访问或不存在的属性时调用"></a>get：读取不可访问或不存在的属性时调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function __get($name)&#123;</span><br><span class="line">    echo $name.&quot;该属性不可获取&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set：给不可访问或不存在的属性赋值时调用"><a href="#set：给不可访问或不存在的属性赋值时调用" class="headerlink" title="set：给不可访问或不存在的属性赋值时调用"></a>set：给不可访问或不存在的属性赋值时调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function __set($name, $value)&#123;</span><br><span class="line">    echo $name.&quot;该属性不可赋值&quot;.$value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isset：当对不可访问对象使用isset或empty时调用"><a href="#isset：当对不可访问对象使用isset或empty时调用" class="headerlink" title="isset：当对不可访问对象使用isset或empty时调用"></a>isset：当对不可访问对象使用isset或empty时调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function __isset($name)&#123;</span><br><span class="line">    echo $name.&quot;正在使用isset&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unset：当对不可访问对象使用unset时调用"><a href="#unset：当对不可访问对象使用unset时调用" class="headerlink" title="unset：当对不可访问对象使用unset时调用"></a>unset：当对不可访问对象使用unset时调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function __unset($name)&#123;</span><br><span class="line">    echo $name.&quot;正在使用unset&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="toString：当一个类被当成字符串打印时调用"><a href="#toString：当一个类被当成字符串打印时调用" class="headerlink" title="toString：当一个类被当成字符串打印时调用"></a>toString：当一个类被当成字符串打印时调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function __toString()&#123;</span><br><span class="line">    echo &quot;该类正在被打印&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文列出php魔法方法什么情况下被调用（未完带续）&lt;/p&gt;
    
    </summary>
    
      <category term="php" scheme="https://rainoceantop.github.io/Jesse/categories/php/"/>
    
      <category term="魔法方法" scheme="https://rainoceantop.github.io/Jesse/categories/php/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="php" scheme="https://rainoceantop.github.io/Jesse/tags/php/"/>
    
      <category term="魔法方法" scheme="https://rainoceantop.github.io/Jesse/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    
      <category term="魔术方法" scheme="https://rainoceantop.github.io/Jesse/tags/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式缓存系统memcached笔记</title>
    <link href="https://rainoceantop.github.io/Jesse/2018/07/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9Fmemcached%E7%AC%94%E8%AE%B0/"/>
    <id>https://rainoceantop.github.io/Jesse/2018/07/23/分布式缓存系统memcached笔记/</id>
    <published>2018-07-22T22:57:00.000Z</published>
    <updated>2018-07-23T23:05:50.797Z</updated>
    
    <content type="html"><![CDATA[<p>Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。</p><a id="more"></a><h4 id="安装向导"><a href="#安装向导" class="headerlink" title="安装向导"></a>安装向导</h4><p>linux安装memcached：<code>sudo pacman -S memcached (manjaro)</code> | <code>sudo apt-get install memcached (ubuntu)</code><br>启动/重启：<code>memcached -m 64m -p 11211 -vv (common)</code> | <code>memcached</code> | <code>memcached start/stop/restart (ubuntu)</code><br>查看运行状态：<code>ps -ef|grep memcached</code><br>查看帮助：<code>memcached -h</code><br>telnet连接：<code>telnet localhost 11211</code></p><hr><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>stats：显示分析详情<br>set：用于将 value(数据值) 存储在指定的 key(键) 中。如果set的key已经存在，则更新其值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set key flags exptime bytes [noreply] </span><br><span class="line">value</span><br></pre></td></tr></table></figure></p><p>add：用于将 value(数据值) 存储在指定的 key(键) 中。 如果 add 的 key 已经存在，则不会更新数据(过期的 key 会更新)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add key flags exptime bytes [noreply]</span><br><span class="line">value</span><br></pre></td></tr></table></figure></p><p>get：获取一个或多个存储在 key(键) 中的 value(数据值) ，如果 key 不存在，则返回空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br><span class="line">get key1 key2 key3</span><br></pre></td></tr></table></figure></p><p>replace：用于替换已存在的 key(键) 的 value(数据值)。如果 key 不存在，则替换失败<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replace key flags exptime bytes [noreply]</span><br><span class="line">value</span><br></pre></td></tr></table></figure></p><p>append：用于向已存在 key(键) 的 value(数据值) 后面追加数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">append key flags exptime bytes [noreply]</span><br><span class="line">value</span><br></pre></td></tr></table></figure></p><p>prepend：用于向已存在 key(键) 的 value(数据值) 前面追加数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prepend key flags exptime bytes [noreply]</span><br><span class="line">value</span><br></pre></td></tr></table></figure></p><p>cas：（Check-And-Set 或 Compare-And-Swap） 命令用于执行一个”检查并设置”的操作，它需要指定当前key的cas_token才可以修改值，cas_token可以用gets获取到，每一次修改key值cas_token都会改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cas key flags exptime bytes unique_cas_token [noreply]</span><br><span class="line">value</span><br></pre></td></tr></table></figure></p><p>delete：用于删除已存在的 key(键)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete key [noreply]</span><br></pre></td></tr></table></figure></p><p>incr|decr：用于对已存在的 key(键) 的数字值进行自增或自减操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incr key increment_value</span><br><span class="line">decr key decrement_value</span><br></pre></td></tr></table></figure></p><p>flush_all：用于清理缓存中的所有 key=&gt;value(键=&gt;值) 对<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush_all [time] [noreply]</span><br></pre></td></tr></table></figure></p><hr><h4 id="语句参数解释"><a href="#语句参数解释" class="headerlink" title="语句参数解释"></a>语句参数解释</h4><pre><code>key：键值 key-value 结构中的 key，用于查找缓存值flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value）unique_cas_token：通过 gets命令获取的一个唯一的64位值increment_value： 增加的数值decrement_value： 减少的数值time：用于在制定的时间后执行清理缓存操作</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。&lt;/p&gt;
    
    </summary>
    
      <category term="缓存技术" scheme="https://rainoceantop.github.io/Jesse/categories/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
      <category term="memcached" scheme="https://rainoceantop.github.io/Jesse/categories/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/memcached/"/>
    
    
      <category term="memcached" scheme="https://rainoceantop.github.io/Jesse/tags/memcached/"/>
    
      <category term="memcache" scheme="https://rainoceantop.github.io/Jesse/tags/memcache/"/>
    
      <category term="缓存技术" scheme="https://rainoceantop.github.io/Jesse/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
      <category term="缓存" scheme="https://rainoceantop.github.io/Jesse/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql优化（配置参数优化）</title>
    <link href="https://rainoceantop.github.io/Jesse/2018/07/10/mysql%E4%BC%98%E5%8C%96/"/>
    <id>https://rainoceantop.github.io/Jesse/2018/07/10/mysql优化/</id>
    <published>2018-07-09T17:55:39.000Z</published>
    <updated>2018-07-10T17:00:08.864Z</updated>
    
    <content type="html"><![CDATA[<p>mysql优化主要分为三个方面<br>1.内核优化（主要由服务器运维人员完成）<br><strong>2.配置参数优化（my.cnf），通过进行压力测试来适当调整配置参数</strong><br>3.SQL语句优化</p><a id="more"></a><p><strong>前言：本文代码必须在mysql环境下实现</strong><br><strong>命令行运行mysql命令：<code>mysql -u 帐号 -p 密码</code></strong></p><h4 id="查看运行时间"><a href="#查看运行时间" class="headerlink" title="查看运行时间"></a>查看运行时间</h4><p>1.<code>select version()</code>：查看数据库版本，只有5.0.37以上版本才支持show profiles（查看语句具体运行时间）<br>2.<code>show variables like &quot;%pro%&quot;</code>：查看profiling是否开启（默认不开启）<br>3.<code>set profiling = 1</code>：开启profiling<br>4.<code>show profiles</code>：查看所有运行过的sql语句的执行时间<br>5.<code>show profile for query 1</code>：查看第一个sql语句执行过程的各个操作的耗时情况<br>6.<code>show profile cpu,block io,memory,swaps,context switches,source for query 1</code>：查看第一个sql语句执行的各种资源消耗情况<br>7.<code>set profiling = 0</code>：关闭profiling</p><h4 id="修改变量"><a href="#修改变量" class="headerlink" title="修改变量"></a>修改变量</h4><p><strong>大部分mysql变量都是可以用set加变量名修改的，具体有以下几种方式</strong><br>1.<code>set profiling = 1/0</code>：开启/关闭profiling，也可以使用2/3/4的命令<br>2.<code>set @@profiling = 1/0</code>：效果如1<br>3.<code>set @@session.profiling = 1/0</code>：效果如1<br>4.<code>set session profiling = 1/0</code>：效果如1<br><strong>set global profiling = 1/0：由于profiling是当前会话级别的，所以该语句无效</strong></p><h4 id="查询变量"><a href="#查询变量" class="headerlink" title="查询变量"></a>查询变量</h4><p><strong>查询变量可用<code>show variables like &#39;%somthing%&#39;</code>查询相关变量，如想查询指定变量可用<code>select @@var_name</code></strong><br>1.GLOBAL：全局变量，修改这个级别的变量影响所有会话<br>2.SESSION：当前会话变量，修改这个级别的变量影响当前会话<br>3.<code>SHOW [GLOBAL | SESSION] VARIABLES [LIKE &#39;pattern&#39; | WHERE expr]</code>：查看变量（全局会话，当前会话）的通用表达式<br>4.<code>select @@global.var_name/@@session.var_name</code>：查看单个变量（完全显示变量名和值）</p><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><p>1.创建变量并赋值：<code>set @name=&#39;hello world&#39;</code>;<br>2.变量赋值：<code>set @name:=author from posts limit 0,1;</code>（将查询到的author栏的第一个值赋值）<br>3.查看变量：<code>select @name</code>;</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="查看是否开启缓存"><a href="#查看是否开启缓存" class="headerlink" title="查看是否开启缓存"></a>查看是否开启缓存</h5><p><code>show variables like &#39;%query_cache%&#39;</code>：如果query_cache_type值是ON的话说明已经开启缓存<br><strong>查询得到的如下属性以及其代表意义</strong></p><ul><li><em>have_query_cache</em>：表示当前版本mysql是否支持query cache</li><li><em>query_cache_limit</em>：指定单个查询能够使用的缓冲区大小，缺省为1M</li><li><em>query_cache_min_res_unit</em>：表示query cache每个结果集存放的最小内存大小，默认4k</li><li><em>query_cache_size</em>：表示系统中用于query cache的内存大小<br>在Mysql中，可以设置Query Cache所使用的总内存,MySQL会把默认可以进行缓存的SQL语句的结果集进行缓存,一旦内存塞满后，就会剔除老的Query Cache对象。同时为了保证Query Cache中的内容与是实际数据绝对一致,当表中的数据有任何变化，包括新增、修改、删除等，都会使所有引用到该表的SQL的Query Cache 失效.</li><li><p><em>query_cache_type</em>：系统是否打开了query cache功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type=0*（OFF）：关闭</span><br><span class="line">query_cache_type=1*（ON）：缓存所有结果，除非select语句使用SQL_NO_CACHE禁用查询缓存</span><br><span class="line">query_cache_type=2*(demand)：只缓存select语句中通过SQL_CACHE指定需要缓存的查询，例如 `select SQL_CACHE count(*) from table`</span><br></pre></td></tr></table></figure></li><li><p><em>query_cache_wlock_invalidate</em>：针对myisam存储引擎，设置当有write lock在某个table上面的时候，读请求是要等待write lock释放资源之后再查询还是允许直接从query cache中读取结果，默认是OFF，可以直接从query cache中取得结果。</p></li></ul><h5 id="开启缓存"><a href="#开启缓存" class="headerlink" title="开启缓存"></a>开启缓存</h5><p>打开配置文件（my.cnf），修改并保存以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]中添加</span><br><span class="line">query_cache_size = 20M</span><br><span class="line">query_cache_type = ON</span><br></pre></td></tr></table></figure></p><h5 id="缓存状态"><a href="#缓存状态" class="headerlink" title="缓存状态"></a>缓存状态</h5><p><code>show status like &#39;qcache%&#39;</code>：可查看缓存状态<br><strong>查询得到的如下属性以及其代表意义</strong></p><ul><li><em>Qcache_free_blocks</em>：缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块</li><li><em>Qcache_free_memory</em>：缓存中的空闲内存。  </li><li><em>Qcache_hits</em>：每次查询在缓存中命中时就增大  </li><li><em>Qcache_inserts</em>：表示未命中cache后将结果集再写入到cache中的次数</li><li><em>Qcache_lowmem_prunes</em>：缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。这个数字最好长时间来看;如果这个 数字在不断增长，就表示可能碎片非常严重，或者内存很少。(上面的 free_blocks和free_memory可以告诉您属于哪种情况)  </li><li><em>Qcache_not_cached</em>：不适合进行缓存的查询的数量，通常是由于这些查询不是SELECT语句或者用了now()之类的函数。  </li><li><em>Qcache_queries_in_cache</em>：当前缓存的查询(和响应)的数量  </li><li><em>Qcache_total_blocks</em>：缓存中块的数量</li></ul><h5 id="评估缓存命中率公式"><a href="#评估缓存命中率公式" class="headerlink" title="评估缓存命中率公式"></a>评估缓存命中率公式</h5><p>Qcache_hits/Com_select （缓存命中次数/总查询次数）<br><strong>当读写操作差不多的时候，建议关闭该功能，但是如果是大量查询,即读多写少的环境中，建议启用缓存</strong><br>注意，第一次查询时生成缓存，接下去的查询才会命中缓存<br>查看Com_select（总查询次数）的总数<br><code>MariaDB [sunny]&gt; show global status like &#39;Com%select%&#39;;</code></p><h5 id="缓存数据失效时机"><a href="#缓存数据失效时机" class="headerlink" title="缓存数据失效时机"></a>缓存数据失效时机</h5><ul><li>在表的结构或数据发生改变时，查询缓存中的数据不再有效</li><li>有这些INSERT、UPDATE、 DELETE、TRUNCATE、ALTER TABLE、DROP TABLE或DROP DATABASE会导致缓存数据失效<br><strong>所以查询缓存适合有大量相同查询的应用，不适合有大量数据更新的应用</strong></li></ul><h5 id="清理查询缓存"><a href="#清理查询缓存" class="headerlink" title="清理查询缓存"></a>清理查询缓存</h5><ul><li><code>FLUSH QUERY CACHE;</code> // 清理查询缓存内存碎片</li><li><code>RESET QUERY CACHE;</code> // 从查询缓存中移出所有查询</li><li><code>FLUSH TABLES;</code> //关闭所有打开的表，同时该操作将会清空查询缓存中的内容</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>1.mysql配置文件：linux一般放在/etc/my.cnf（xampp集成环境在lampp下的etc中）<br>2.查询mysql变量的单位：B（也就是如果你设置query_cache_size=20M，那么查询该变量时会显示20*1024*1024的值）<br>3.如果使用的数据库引擎是innodb，那么innodb_buffer_pool_size是一个对于优化很重要的变量，可以缓存表的索引，数据，插入数据时的缓冲，值越大，可缓存的数据越多，就不需要频繁地进行磁盘I/O读写操作。如果是一个专用DB服务器，那么他可以占到内存的70%-80%。<strong>但是也不是越大越好，分配过大，会使Swap占用过多，致使Mysql的查询特慢</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql优化主要分为三个方面&lt;br&gt;1.内核优化（主要由服务器运维人员完成）&lt;br&gt;&lt;strong&gt;2.配置参数优化（my.cnf），通过进行压力测试来适当调整配置参数&lt;/strong&gt;&lt;br&gt;3.SQL语句优化&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://rainoceantop.github.io/Jesse/categories/mysql/"/>
    
      <category term="优化配置" scheme="https://rainoceantop.github.io/Jesse/categories/mysql/%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="mysql" scheme="https://rainoceantop.github.io/Jesse/tags/mysql/"/>
    
      <category term="mysql优化" scheme="https://rainoceantop.github.io/Jesse/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
      <category term="mysql优化配置" scheme="https://rainoceantop.github.io/Jesse/tags/mysql%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>linux下php集成环境配置</title>
    <link href="https://rainoceantop.github.io/Jesse/2018/06/18/linux%E4%B8%8Bphp%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://rainoceantop.github.io/Jesse/2018/06/18/linux下php集成环境配置/</id>
    <published>2018-06-17T23:02:54.000Z</published>
    <updated>2018-06-18T15:38:49.065Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解linux下配置php集成环境。主要有以下内容：</p><ul><li>xampp的下载以及安装</li><li>apache以及mysql的启动与停止</li><li>修改配置文件</li></ul><a id="more"></a><h3 id="xampp的下载与安装"><a href="#xampp的下载与安装" class="headerlink" title="xampp的下载与安装"></a>xampp的下载与安装</h3><p>xampp可在<a href="https://www.apachefriends.org/zh_cn/download.html" target="_blank" rel="noopener">官方网站的下载页</a>下载，下载完打开下载目录，可以看到有一个名类似为<code>xampp-linux-x64-xxxxx-x-installer.run</code>的安装文件。<br>打开终端命令行，键入以下代码进行安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//首先进入到xampp安装文件的目录，我的是下载目录</span><br><span class="line"><span class="built_in">cd</span> 下载</span><br><span class="line">//然后运行安装文件启动安装程序，一般情况下一直点击next即可，xampp一般情况下会被安装在/opt目录下的lampp</span><br><span class="line">sudo ./xampp-linux-x64-xxxxx-x-installer.run</span><br></pre></td></tr></table></figure></p><h3 id="apache以及mysql"><a href="#apache以及mysql" class="headerlink" title="apache以及mysql"></a>apache以及mysql</h3><h4 id="命令行启动停止操作（推荐）"><a href="#命令行启动停止操作（推荐）" class="headerlink" title="命令行启动停止操作（推荐）"></a>命令行启动停止操作（推荐）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /opt/lampp/lampp start    //启动服务</span><br><span class="line">sudo /opt/lampp/lampp restart  //重启服务</span><br><span class="line">sudo /opt/lampp/lampp stop     //停止服务</span><br></pre></td></tr></table></figure><h4 id="图形管理界面操作"><a href="#图形管理界面操作" class="headerlink" title="图形管理界面操作"></a>图形管理界面操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /opt/lampp/manager-linux-x64.run //打开图形管理界面</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Jesse/2018/06/18/linux下php集成环境配置/xampp_panel.png" alt="图形管理界面" title="">                </div>                <div class="image-caption">图形管理界面</div>            </figure><p><strong>启动服务后建议打开浏览器输入localhost网址看下有没有运行成功</strong></p><h3 id="修改apache默认执行路径"><a href="#修改apache默认执行路径" class="headerlink" title="修改apache默认执行路径"></a>修改apache默认执行路径</h3><p>apache的默认执行路径是项目文件夹的htdocs目录，因为xampp是安装在linux根目录的opt文件夹下面，由于权限问题是不能创建文件以及文件夹的。为了方便操作，我们可以把他的执行路径更改到可方便操作的地方，比如用户下面(<code>/home/user/</code>)。<br>xampp的配置文件放在该目录的etc文件夹中，由于权限问题，如果要更改执行路径可以用命令行通过nano操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//通过nano打开apache配置文件，注意要用sudo管理员身份打开</span><br><span class="line">sudo nano /opt/lampp/etc/httpd.conf</span><br><span class="line">//找到下面两行，将路径改为你的项目路径</span><br><span class="line">DocumentRoot <span class="string">"/home/user/yourapp"</span></span><br><span class="line">&lt;Directory <span class="string">"/home/user/yourapp"</span>&gt;</span><br><span class="line">//打开apache下的config文件</span><br><span class="line">sudo nano /opt/lampp/apache2/conf/httpd.conf</span><br><span class="line">//继续修改路径</span><br><span class="line">&lt;Directory <span class="string">"/home/user/yourapp"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>修改完后按<code>ctrl o</code>保存，<code>ctrl x</code>退出编辑，然后输入<code>sudo /opt/lampp/lampp restart</code>重启apache服务器</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="mysql操作"><a href="#mysql操作" class="headerlink" title="mysql操作"></a>mysql操作</h4><p>因为xampp自带phpmyadmin，我们可以很方便的查看以及操作数据库。<br>在打开了apache以及mysql服务后，在浏览器输入<code>localhost/phpmyadmin</code>即可进入数据库图形操作界面（自动登录）。<br>值得注意的是，phpmyadmin默认的帐号是root，密码为空，也就是””，与mysql相同（可以打开<code>/opt/lampp/phpmyadmin/config.inc.php</code>查看）。如果要连接mysql数据库，使用帐号<code>root</code>密码<code>&quot;&quot;</code>连接即可。</p><h4 id="php解释器路径"><a href="#php解释器路径" class="headerlink" title="php解释器路径"></a>php解释器路径</h4><p>xampp的php解释器默认情况下放在<code>/opt/lampp/bin/php</code>，可以在命令行键入<code>whereis php</code>查看</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲解linux下配置php集成环境。主要有以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xampp的下载以及安装&lt;/li&gt;
&lt;li&gt;apache以及mysql的启动与停止&lt;/li&gt;
&lt;li&gt;修改配置文件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux" scheme="https://rainoceantop.github.io/Jesse/categories/linux/"/>
    
      <category term="php" scheme="https://rainoceantop.github.io/Jesse/categories/linux/php/"/>
    
      <category term="环境配置" scheme="https://rainoceantop.github.io/Jesse/categories/linux/php/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="linux" scheme="https://rainoceantop.github.io/Jesse/tags/linux/"/>
    
      <category term="php" scheme="https://rainoceantop.github.io/Jesse/tags/php/"/>
    
      <category term="php集成环境配置" scheme="https://rainoceantop.github.io/Jesse/tags/php%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>manjaro基本设置</title>
    <link href="https://rainoceantop.github.io/Jesse/2018/06/05/manjaro%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/"/>
    <id>https://rainoceantop.github.io/Jesse/2018/06/05/manjaro基本设置/</id>
    <published>2018-06-04T23:11:33.000Z</published>
    <updated>2018-06-05T00:38:23.738Z</updated>
    
    <content type="html"><![CDATA[<p>Manjaro是一款基于Arch Linux、对用户友好、全球排名第1的Linux发行版。详情参见<a href="https://distrowatch.com/dwres.php?resource=popularity" target="_blank" rel="noopener">distrowatch</a><br>这篇文章主要是将manjaro刚安装完需要设置的东西罗列出来，一切都是为了在使用中尽量减少碰见的问题<br>附上manjaro的相关链接：<br><a href="https://www.manjaro.cn/" target="_blank" rel="noopener">manjaro中文网</a><br><a href="http://manjaro.github.io/" target="_blank" rel="noopener">manjaro官方网站</a><br><a href="https://zhuanlan.zhihu.com/p/35663653" target="_blank" rel="noopener">manjaro安装参考</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3223425153,1628165458&fm=27&gp=0.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><h3 id="配置国内源"><a href="#配置国内源" class="headerlink" title="配置国内源"></a>配置国内源</h3><p>打开manjaro命令行（菜单里的终端模拟器），键入如下两行代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//由于各方面原因，有些命令可能不起作用，前三行代码逐个测试，可以之后跳到更新系统</span><br><span class="line">sudo pacman-mirrors -gb testing -c China //选择中国源，可选一个或多个或全选</span><br><span class="line">sudo pacman-mirrors -b testing -c China</span><br><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br><span class="line">sudo pacman -Syyu  //更新系统</span><br></pre></td></tr></table></figure></p><h3 id="升级软件"><a href="#升级软件" class="headerlink" title="升级软件"></a>升级软件</h3><p>由于配置了中国源，现在就不受网速限制了。看到右下角的软件包管理器提醒你更新软件了吗？打开它并更新软件至最新版本</p><h3 id="配置输入法"><a href="#配置输入法" class="headerlink" title="配置输入法"></a>配置输入法</h3><p>在软件管理包搜索并下载谷歌拼音，通过软件包管理器下载输入法会同时下载相关依赖，如fcitx。<br><strong>下载完重启才能开启输入法（至少目前我不知道还有其他方法）</strong><br>如果发现不能配置输入法，打开命令行键入以下命令后再重试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-im</span><br><span class="line">sudo pacman -S fcitx-configtool</span><br></pre></td></tr></table></figure></p><p>在配置界面里可以配置输入法的切换激活快捷键，但还差最后一步配置才能正常使用输入法<br>打开命令行，键入以下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo nano ~/.xprofile </span><br><span class="line">//进入编辑页面后，复制以下代码粘贴上去，然后根据提示保存后离开重试</span><br><span class="line"><span class="comment">#fcitx</span></span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx </span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx </span><br><span class="line"><span class="built_in">export</span> XMODIFIERS=<span class="string">"@im=fcitx"</span></span><br></pre></td></tr></table></figure></p><h3 id="时间调整"><a href="#时间调整" class="headerlink" title="时间调整"></a>时间调整</h3><p>如果你使用的是双系统（manjaro和windows并存），那么你可能会遇到时间比你所在时区的正常时间快了8个小时。这是因为linux和windows看待系统硬件的方式是不一样的<br>Windows把系统硬件时间当作本地时间(local time),即操作系统中显示的时间跟BIOS中显示的时间是一样的。 Linux/Unix/Mac把硬件时间当作UTC，操作系统中显示的时间是硬件时间经过换算得来的，比如说北京时间是GMT+8，则系统中显示时间是硬件时间+8。<br>解决方法其实也很简单，只要进入windows系统。通过右击时间显示区，打开日期和时间，修改时区为<code>(UTC)协调世界时</code>即可</p><h3 id="win10系统下关机后自动重启"><a href="#win10系统下关机后自动重启" class="headerlink" title="win10系统下关机后自动重启"></a>win10系统下关机后自动重启</h3><p>进入电源选项（控制面板或左下角搜索栏搜索电源）→选择电源按钮的功能→更改当前不可用的设置→取消勾选“启用快速启动”功能 即可</p><h3 id="添加archlinuxCN源"><a href="#添加archlinuxCN源" class="headerlink" title="添加archlinuxCN源"></a>添加archlinuxCN源</h3><p>打开命令行，键入以下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/pacman.conf</span><br><span class="line">//进入编辑页面后，在文件底部加入如下几行，保存离开</span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Optional TrustedOnly</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="variable">$arch</span></span><br><span class="line">//配置完后键入以下命令</span><br><span class="line">sudo pacman-mirrors -g //更新并选择最快的源列表</span><br><span class="line">pacman -S archlinux-keying //更新archlinux签名</span><br><span class="line">sudo pacman -S yaourt //用于软件安装arch源的软件</span><br><span class="line">sudo pacman -Syyu //同步并更新系统</span><br></pre></td></tr></table></figure></p><h3 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h3><p>如果已经安装了archlinuxcn源，可以打开软件包管理器-&gt;首选项-&gt;AUR-&gt;启用AUR支持，然后就可以直接在管理器里下载需要的软件了<br>或者也可以使用命令行安装，以下列出两个例子</p><h4 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yaourt -S netease-cloud-music</span><br></pre></td></tr></table></figure><h4 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yaourt -S electronic-wechat</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Manjaro是一款基于Arch Linux、对用户友好、全球排名第1的Linux发行版。详情参见&lt;a href=&quot;https://distrowatch.com/dwres.php?resource=popularity&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;distrowatch&lt;/a&gt;&lt;br&gt;这篇文章主要是将manjaro刚安装完需要设置的东西罗列出来，一切都是为了在使用中尽量减少碰见的问题&lt;br&gt;附上manjaro的相关链接：&lt;br&gt;&lt;a href=&quot;https://www.manjaro.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;manjaro中文网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://manjaro.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;manjaro官方网站&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35663653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;manjaro安装参考&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3223425153,1628165458&amp;fm=27&amp;gp=0.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="linux" scheme="https://rainoceantop.github.io/Jesse/categories/linux/"/>
    
      <category term="manjaro" scheme="https://rainoceantop.github.io/Jesse/categories/linux/manjaro/"/>
    
      <category term="基本设置" scheme="https://rainoceantop.github.io/Jesse/categories/linux/manjaro/%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/"/>
    
    
      <category term="linux" scheme="https://rainoceantop.github.io/Jesse/tags/linux/"/>
    
      <category term="archlinux" scheme="https://rainoceantop.github.io/Jesse/tags/archlinux/"/>
    
      <category term="manjaro" scheme="https://rainoceantop.github.io/Jesse/tags/manjaro/"/>
    
      <category term="manjaro基本设置" scheme="https://rainoceantop.github.io/Jesse/tags/manjaro%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>linux基础</title>
    <link href="https://rainoceantop.github.io/Jesse/2018/06/05/linux%E5%9F%BA%E7%A1%80/"/>
    <id>https://rainoceantop.github.io/Jesse/2018/06/05/linux基础/</id>
    <published>2018-06-04T21:59:02.000Z</published>
    <updated>2018-07-22T23:33:13.957Z</updated>
    
    <content type="html"><![CDATA[<p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。<br>严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。<br>开发者：Linus Torvalds（同时也是git的开发者）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1923395011,885347984&fm=27&gp=0.jpg" alt="Linux吉祥物 Tux" title="">                </div>                <div class="image-caption">Linux吉祥物 Tux</div>            </figure></p><a id="more"></a><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><pre><code>进入目录：cd mulu/mulu2返回目录：cd ../..返回最上层目录：cd -返回home : cd ~绝对路径进入目录：cd /home/jesse/Documents/folder</code></pre><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><pre><code>创建文件：touch file1.txt file2 file3创建文件夹：mkdir folder3</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre><code>删除文件夹：rmdir folder3(删除空文件夹)删除文件/文件夹：    rm file1    rm -r folder1/(递归逐个删除)    rm -i file1 file2 file3 file4(逐个提示是否删除)    rm -I file1 file2 file3 file4(大于三个文件时提示是否删除)    rm *(清空该目录下所有文件)    rm /(清空系统所有文件)</code></pre><h4 id="复制-amp-剪切"><a href="#复制-amp-剪切" class="headerlink" title="复制&amp;剪切"></a>复制&amp;剪切</h4><pre><code>复制文件：    cp file1 filecopy(如果存在会覆盖)    cp -i file1 filecopy(如果存在会提示)    cp file1 folder/(复制到文件夹folder中，/识别文件夹)    cp -R folder/ folder2/(-R代表递归，逐个将folder的文件复制到folder2中)    cp file* folder2/(将所有file开头的文件复制到folder2目录下)    cp *file folder2/(将所有file结尾的文件复制到folder2目录下)    cp file1 file2 file3 folder2/(将前面所有的东西复制到最后所指的目录)剪切：    mv file1 folder/  (移动到当前文件夹的folader文件夹下)    mv file1 ./folder (同上，移动到当前文件夹的folader文件夹下)    mv file1 ./folder file2 (移动到当前文件夹的folader文件夹下并重命名为file2)    mv file1 /folder (!此操作会将文件移动到根目录)</code></pre><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><pre><code>查看当前目录下的文件列表：ls查看当前目录下的文件列表的详细信息：ls -l 或者 ls -lh(适合人类看的)查看当前目录下的所有文件列表：ls -a查看ls的所有功能：ls --helpnano编辑文件(功能命令^代表ctrl键)：nano t.py(不存在文件的话会自动创建文件)cat编辑文件：    cat t.py(显示文件内容)    cat t.py &gt; t1.py(将t.py的内容复制到t1.py中)    cat t.py t1.py &gt; t2.py(将t.py t1.py的内容复制到t2.py中)    cat t3.py &gt;&gt; t2.py(将t3.py的内容加到t2.ty的后面)</code></pre><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><pre><code>运行python3文件：python3 t.py（被执行文件头部需要有解释器声明 #!/usr/bin/python3）</code></pre><h3 id="权限操作"><a href="#权限操作" class="headerlink" title="权限操作"></a>权限操作</h3><h4 id="权限解读"><a href="#权限解读" class="headerlink" title="权限解读"></a>权限解读</h4><pre><code>第1代表类型，第2-4代表user，第5-7代表group，第8-10代表其他的权限，例如：drwxr-xr-x：d代表文件夹类型，r代表可读，w代表可写，x代表可执行(执行命令：./t1.py)-rw-r--r--：第一个-代表文件类型</code></pre><h4 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h4><pre><code>chmod u+r t1.py(为user用户t1.py增加可读权限)chmod u+rwx t1.py(为user用户t1.py增加可读可写可执行权限)chmod u-r t1.py(为user用户t1.py减去可读权限)chmod g+r t1.py(为group用户t1.py增加可读权限)chmod o+r t1.py(为others用户t1.py增加可读权限)chmod a+r t1.py(为全部用户t1.py增加可读权限)chmod ug+r t1.py(为user,group用户t1.py增加可读权限)</code></pre><h3 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h3><pre><code>下载linux SSH终端：sudo apt-get install openssh-server获取ip地址：ifconfig(如果提示没安装一些东西：sudo apt install net-tools)用mac控制linux：ssh jesse@192.168.0.108用windows控制：下载PuTTY手机控制：下载ssh应用控制后图形界面显示：  使用外网 Teamviewer  使用局域网 VNC(sudo apt-get install x11vnc)mac将文件推送到linux运行：ssh jesse@192.168.0.108 python3 &lt; t1.py(将t1.py推送到linux上运行)将文件复制到linux上：scp {a,b}.py jesse@192.168.0.108:~/Desktop/从linux云端保存到本地：scp jesse@192.168.0.108:~/Desktop/b.py c.py控制云端弹出窗口：ssh jesse@192.168.0.108 &quot;export DISPLAY:0; firefox&quot;</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>清空命令行：clear下载软件：sudo apt-get install xxxxx （arch系列的linux不适用）        sudo pacman -S xxxxx (manjaro)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。&lt;br&gt;严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。&lt;br&gt;开发者：Linus Torvalds（同时也是git的开发者）&lt;br&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1923395011,885347984&amp;fm=27&amp;gp=0.jpg&quot; alt=&quot;Linux吉祥物 Tux&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;Linux吉祥物 Tux&lt;/div&gt;
            &lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://rainoceantop.github.io/Jesse/categories/linux/"/>
    
      <category term="基础" scheme="https://rainoceantop.github.io/Jesse/categories/linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="linux" scheme="https://rainoceantop.github.io/Jesse/tags/linux/"/>
    
      <category term="linux基础" scheme="https://rainoceantop.github.io/Jesse/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="linux基本指令" scheme="https://rainoceantop.github.io/Jesse/tags/linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>git的基本命令</title>
    <link href="https://rainoceantop.github.io/Jesse/2018/06/05/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>https://rainoceantop.github.io/Jesse/2018/06/05/git的基本命令/</id>
    <published>2018-06-04T21:02:42.000Z</published>
    <updated>2018-06-04T22:42:42.448Z</updated>
    
    <content type="html"><![CDATA[<p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>开发者：Linus Torvalds（同时也是linux的开发者，<strong>他是神↓</strong>）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1528156573582&di=3e846e62c187ef6710eb2e3e0545eb62&imgtype=jpg&src=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D2475420643%2C1638975679%26fm%3D214%26gp%3D0.jpg" alt="Linus Torvalds" title="">                </div>                <div class="image-caption">Linus Torvalds</div>            </figure><a id="more"></a><h3 id="身份象征"><a href="#身份象征" class="headerlink" title="身份象征"></a>身份象征</h3><h4 id="确定身份象征-提交任何修改使用"><a href="#确定身份象征-提交任何修改使用" class="headerlink" title="确定身份象征(提交任何修改使用)"></a>确定身份象征(提交任何修改使用)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">""</span></span><br><span class="line">git config --global user.email <span class="string">""</span></span><br></pre></td></tr></table></figure><h4 id="查看身份象征"><a href="#查看身份象征" class="headerlink" title="查看身份象征"></a>查看身份象征</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><h3 id="操作项目"><a href="#操作项目" class="headerlink" title="操作项目"></a>操作项目</h3><h4 id="确定管理项目"><a href="#确定管理项目" class="headerlink" title="确定管理项目"></a>确定管理项目</h4><p><code>cd进入到该项目目录</code></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>git init</code></p><h4 id="查看管理库状态"><a href="#查看管理库状态" class="headerlink" title="查看管理库状态"></a>查看管理库状态</h4><blockquote><p>查看普通状态<br><code>git status</code><br>查看修改状态<br><code>git status -s</code></p></blockquote><h4 id="添加可提交修改（commited）文件（stage状态的文件）"><a href="#添加可提交修改（commited）文件（stage状态的文件）" class="headerlink" title="添加可提交修改（commited）文件（stage状态的文件）"></a>添加可提交修改（commited）文件（stage状态的文件）</h4><blockquote><p>提交单个文件<br><code>git add 1.py</code><br>提交所有文件<br><code>git add .</code><br>撤销提交的文件<br><code>git reset 1.py</code></p></blockquote><h4 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h4><blockquote><p>直接提交<br><code>git commit -m &quot;提交信息&quot;</code><br>直接提交并添加<br><code>git commit -am &quot;提交信息&quot;（已经管理库有的文件，新文件无法识别到）</code><br>提交文件至上次提交的分支<br><code>git commit --amend（上次分支） --no-edit（不修改-m信息）</code></p></blockquote><h4 id="打印git日志"><a href="#打印git日志" class="headerlink" title="打印git日志"></a>打印git日志</h4><blockquote><p>直接打印<br><code>git log</code><br>简洁打印<br><code>git log --oneline</code><br>简洁图形打印<br><code>git log --oneline --graph</code></p></blockquote><h4 id="查看修改信息"><a href="#查看修改信息" class="headerlink" title="查看修改信息"></a>查看修改信息</h4><blockquote><p>查看已修改未添加的修改信息<br><code>git diff</code><br>查看已添加的修改信息<br><code>git diff --cached</code><br>查看已添加再修改文件的修改信息<br><code>git diff HEAD</code></p></blockquote><h4 id="修改当前的头分支"><a href="#修改当前的头分支" class="headerlink" title="修改当前的头分支"></a>修改当前的头分支</h4><p><code>git reset --hard (分支id号或HEAD指针（HEAD@{0}）)</code></p><h4 id="重置单个文件的内容信息"><a href="#重置单个文件的内容信息" class="headerlink" title="重置单个文件的内容信息"></a>重置单个文件的内容信息</h4><p><code>git checkout 分支id号 -- 1.py</code></p><h4 id="暂存任务"><a href="#暂存任务" class="headerlink" title="暂存任务"></a>暂存任务</h4><blockquote><p>暂存当前任务<br><code>git stash</code><br>取出暂存任务<br><code>git stash pop</code></p></blockquote><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><blockquote><p>创建分支<br><code>git branch dev 或者 git checkout -b dev(创建并切换到该分支)</code><br>查看分支<br><code>git branch</code><br>切换分支<br><code>git checkout dev</code><br>删除分支<br><code>git branch -d dev</code><br>合并分支<br><code>git merge --no-ff -m &quot;合并信息&quot; dev</code><br>合并分支<br><code>git rebase dev</code></p></blockquote><h4 id="git工作流程图"><a href="#git工作流程图" class="headerlink" title="git工作流程图"></a>git工作流程图</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1526969275687&di=39008720c7a6be94f84e01fb027878ad&imgtype=jpg&src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D2476305079%2C1118351419%26fm%3D214%26gp%3D0.jpg" alt="git工作流程图" title="">                </div>                <div class="image-caption">git工作流程图</div>            </figure><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><h4 id="建立远程连接"><a href="#建立远程连接" class="headerlink" title="建立远程连接"></a>建立远程连接</h4><p><code>git remote add origin xxxxxxxxxx.git</code></p><h4 id="从远程取分支的更新并与本地指定分支结合"><a href="#从远程取分支的更新并与本地指定分支结合" class="headerlink" title="从远程取分支的更新并与本地指定分支结合"></a>从远程取分支的更新并与本地指定分支结合</h4><p><code>git pull origin remotebranch:localbranch</code></p><h4 id="远程分支的更新与当前分支结合"><a href="#远程分支的更新与当前分支结合" class="headerlink" title="远程分支的更新与当前分支结合"></a>远程分支的更新与当前分支结合</h4><p><code>git pull origin remotebranch</code></p><h4 id="将本地分支上传到远程分支"><a href="#将本地分支上传到远程分支" class="headerlink" title="将本地分支上传到远程分支"></a>将本地分支上传到远程分支</h4><p><code>git push -u origin master</code></p><h4 id="将本地分支强制上传到远程分支"><a href="#将本地分支强制上传到远程分支" class="headerlink" title="将本地分支强制上传到远程分支"></a>将本地分支强制上传到远程分支</h4><p><code>git push -fu origin master（覆盖掉远程分支的所有文件）</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。&lt;br&gt;开发者：Linus Torvalds（同时也是linux的开发者，&lt;strong&gt;他是神↓&lt;/strong&gt;）&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1528156573582&amp;di=3e846e62c187ef6710eb2e3e0545eb62&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D2475420643%2C1638975679%26fm%3D214%26gp%3D0.jpg&quot; alt=&quot;Linus Torvalds&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;Linus Torvalds&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="git" scheme="https://rainoceantop.github.io/Jesse/categories/git/"/>
    
      <category term="基本命令" scheme="https://rainoceantop.github.io/Jesse/categories/git/%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="git" scheme="https://rainoceantop.github.io/Jesse/tags/git/"/>
    
      <category term="git基本命令" scheme="https://rainoceantop.github.io/Jesse/tags/git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
      <category term="git基础" scheme="https://rainoceantop.github.io/Jesse/tags/git%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
