{"meta":{"title":"Jesse","subtitle":"个人博客","description":"通过这个博客来记录学习笔记以及一些学习上遇到的问题","author":"Jesse","url":"https://rainoceantop.github.io/Jesse"},"pages":[{"title":"categories","date":"2018-06-04T17:48:09.000Z","updated":"2018-06-04T17:48:34.545Z","comments":false,"path":"categories/index.html","permalink":"https://rainoceantop.github.io/Jesse/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-04T17:47:00.000Z","updated":"2018-06-04T17:47:46.438Z","comments":false,"path":"tags/index.html","permalink":"https://rainoceantop.github.io/Jesse/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NoSQL非关系型数据库redis笔记","slug":"NoSQL非关系型数据库redis笔记","date":"2018-07-23T22:45:45.000Z","updated":"2018-07-24T00:30:35.620Z","comments":true,"path":"2018/07/24/NoSQL非关系型数据库redis笔记/","link":"","permalink":"https://rainoceantop.github.io/Jesse/2018/07/24/NoSQL非关系型数据库redis笔记/","excerpt":"redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。","text":"redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 安装向导linux安装：sudo pacman -S redis (manjaro) | sudo apt-get install redis-server (ubuntu)运行客户端：redis-cli遇到Could not connect to Redis at 127.0.0.1:6379: Connection refused问题：1.如果/etc目录下没有redis.conf，将redis.conf复制到/etc目录下2.打开redis.conf，将daemonize的值no改为yes，默认启动后台运行3.开启sudo redis-server /etc/redis.conf服务端4.重新运行redis客户端 redis-cli，输入ping，如果返回pong说明运行成功注：redis关键字不区分大小写，本笔记为了防止混淆，所有redis字段用大写 字符串set | get：设置|获取 对象123456SET foo 100SET foo &quot;hello&quot; EX 10 ：10秒过期SET foo &quot;hello&quot; PX 1000：1000毫秒或1秒过期SET foo &quot;hello&quot; NX ：只有foo键不存在值时才操作SET foo &quot;hello&quot; XX ：只有foo键存在值时才操作GET foo mset | mget：设置|获取 多个对象12MSET foo &quot;hello&quot; bar &quot;world&quot;MGET foo bar strlen：返回对象字符串值的长度1STRLEN foo append：给对象字符串追加值1APPEND foo &quot; world&quot; rename：修改key的名称1RENAME foo bar del：删除对象1DEL foo expire：设置过期秒数pexpire：设置过期毫秒数expireat：设置过期时间戳ttl：查看剩余秒数过期pttl：查看剩余毫秒数过期persist：移除过期时间123456EXPIRE foo 10PEXPIRE foo 1000EXPIREAT foo timestamp_valTTL fooPTTL fooPERSIST foo incr | decr：数字自增|自减 112INCR fooDECR foo exists：查看对象是否存在，可同时查看多个12EXISTS fooEXISTS foo bar LIST列表lpush | rpush：将元素 左推|右推 进列表，列表不存在则创建新列表123LPUSH mylist &quot;hello&quot; RPUSH mylist &quot;world&quot;RPUSH mylist &quot;hello&quot; &quot;world&quot; lpushx | rpushx：将元素 左推|右推 进列表，列表不存在则操作失败12LPUSHX mylist &quot;hello&quot; RPUSHX mylist &quot;world&quot; lrange：获取列表元素值1LRANGE mylist 0 -1 llen：获取列表长度1LLEN mylist lpop | rpop： 左弹出|右弹出列表12LPOP mylistRPOP mylist rpoplpush：从列表中右弹出一个元素，将弹出的元素左插入到另外一个列表中并返回它；如果列表没有元素返回nil1RPOPLPUSH mylist1 mylist2 linsert：插入元素12LINSERT mylist BEFORE &quot;world&quot; &quot;insert text1&quot;LINSERT mylist AFTER &quot;hello&quot; &quot;insert text2&quot; lindex：返回列表中该索引的元素1LINDEX mylist 0 blpop | brpop：移出并获取列表的第一|最后个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止12BLPOP mylist 10BRPOP mylist 10 brpoplpush：从列表中右弹出一个元素，将弹出的元素左插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止1BRPOPLPUSH mylist1 mylist2 lrem：根据参数 count的值，移除列表中与参数 value相等的元素 语法 ： lrem key count value count &gt; 0 ： 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT count &lt; 0 ： 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值 count = 0 ： 移除表中所有与 VALUE 相等的值1LREM mylist 1 &apos;foo&apos; lset：通过索引设置元素的值1LSET mylist 0 &apos;new one&apos; ltrim：设置区间裁剪列表，区间外元素全部丢弃1LTRIM mylist 0 5 SET集合sadd：将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略1SADD people &quot;nancy&quot; &quot;mike&quot; &quot;kevin&quot; &quot;david&quot; scard：返回集合中元素的数量1SCARD people sdiff：返回与第一个给定集合的差集。不存在的集合 key 将视为空集1SDIFF people people2 sdiffstore：将与第一个给定集合的差集存储在给指定集合中，如果指定集合已存在则会被覆盖1SDIFFSTORE people3 people people2 sinter：返回给定所有给定集合的交集。不存在的集合 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)1SINTER people people2 sinterstore：将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖1SINTERSTORE people4 people people2 sismember：判断成员元素是否是集合的成员1SISMEMBER people &quot;nancy&quot; smembers：返回集合中所有的元素1SMEMBERS people smove：将指定成员 member 元素从 source 集合移动到 destination 集合 SMOVE 是原子性操作 如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除 当 source 或 destination 不是集合类型时，返回一个错误1SMOVE people people2 &quot;mike&quot; spop：移除并返回集合中的一个随机元素1SPOP people srandmember：返回随机元素 语法：srandmember myset [count] 如果 count 为正数，且小于集合基数，那么命令返回一个包含 count个元素的数组，数组中的元素各不相同。如果 count大于等于集合基数，那么返回整个集合 如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count的绝对值1SRANDMEMBER people -3 srem：移除集合中的一个或多个成员元素，不存在的成员元素会被忽略1SREM people &quot;kevin&quot; &quot;david&quot; sunion：返回给定集合的并集。不存在的集合 key 被视为空集1SUNION people people2 people3 people4 sunionstore：将给定集合的并集存储在指定的集合 destination 中。如果 destination 已经存在，则将其覆盖1SUNIONSTORE people5 people people2 people3 people4 sscan：用于迭代集合中键的元素，返回迭代后当前指针位置以及找到的元素 语法：SSCAN key cursor [MATCH pattern] [COUNT count]1SSCAN people 0 MATCH *i* COUNT 10 SET有序集合zadd：将一个或多个成员元素及其分数值加入到有序集当中 语法：ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN 如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上 分数值可以是整数值或双精度浮点数 如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作 当 key 存在但不是有序集类型时，返回一个错误1ZADD users 1995 &quot;david&quot; 1996 &quot;mike&quot; 1997 &quot;nancy&quot; 1998 &quot;andy&quot; 1999 &quot;aaron&quot; zcard：计算集合中元素的数量1ZCARD users zcount：计算有序集合中指定分数区间的成员数量1ZCOUNT users 1996 1998 zincrby：对有序集合中指定成员的分数加上增量，可负数。当集合不存在则创建新有序集合1ZINCRBY users -5 &quot;andy&quot; zinterstore：计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 语法：ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 参数WEIGHTS：将分数以倍数相乘 参数AGGREGATE：以哪种方式进行分数计算，sum相加，min最小，max最大1ZINTERSTORE users3 2 users users2 WEIGHTS 2 3 AGGREGATE MAX zrange：返回有序集中，指定区间内的成员。其中成员的位置按分数值递增(从小到大)来排序。返回分数最后加withscores1ZRANGE users 0 -1 WITHSCORES zrevrange：返回有序集中，指定区间内的成员。其中成员的位置按分数值递减(从大到小)来排列1ZREVRANGE users 0 -1 WITHSCORES zrangebyscore：返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)1ZRANGEBYSCORE users 1996 (1999 zrank：返回有序集中指定成员的排名。排名数字越小分数越大1ZRANK users andy zrevrank：返回有序集中指定成员的排名。排名数字越大分数越大1ZREVRANK users andy zrem：移除有序集中的一个或多个成员，不存在的成员将被忽略1ZREM mike andy aaron zremrangebyrank：移除有序集中，指定排名(rank)区间内的所有成员1ZREMRANGEBYRANK users 2 3 zremrangebyscore：移除有序集中，指定分数（score）区间内的所有成员1ZREMRANGEBYSCORE users 1996 1998 zscore：返回有序集中，成员的分数值。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 nil1ZSCORE users aaron zunionstore：算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 语法和参数与zinterstore一致1ZUNIONSTORE users3 2 users users2 WEIGHTS 2 3 AGGREGATE MAX zscan：用于迭代有序集合中的元素（包括元素成员和元素分值）1ZSCAN users 0 MATCH *a* HSET哈希表hset：为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，旧值将被覆盖。hget：返回哈希表中指定字段的值12HSET website google &quot;google.com&quot;HGET website google hmset：同时将多个 field-value(字段-值)对设置到哈希表中。此命令会覆盖哈希表中已存在的字段。如果哈希表不存在，会创建一个空哈希表，并执行 HMSET操作hmget：返回哈希表中，一个或多个给定字段的值12HMSET website baidu &quot;baidu.com&quot; huawei &quot;huawei.com&quot; facebook &quot;facebook.com&quot; visitor 2000125HMGET website baidu huawei facebook hlen：获取哈希表中字段的数量1HLEN website hkeys：获取哈希表中的所有域（field）hvals：获取哈希表中所有值12HKEYS websiteHVALS website hgetall：获取在哈希表中指定 key 的所有字段和值1HGETALL website hexists：查看哈希表的指定字段是否存在1HEXISTS website google hdel：删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略1HDEL website baidu facebook hincrby：用于为哈希表中的字段值加上指定增量值 增量也可以为负数，相当于对指定字段进行减法操作 如果哈希表的 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令 如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 对一个储存字符串值的字段执行 HINCRBY 命令将造成一个错误 本操作的值被限制在 64 位(bit)有符号数字表示之内。1HINCRBY website visitor 100 hincrbyfloat:为哈希表中的字段值加上指定浮点数增量值。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 01HINCRBYFLOAT website mark 9.8 hsetnx：为哈希表中不存在的的字段赋值，如果字段已经存在于哈希表中，操作无效。如果哈希表不存在则创建1HSETNX website google &quot;hello world&quot; hscan：迭代哈希表中的键值对1HSCAN website 0 MATCH *o* HYPERLOGLOG基数统计用途用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素 pfadd：添加指定元素（一或多）到 HyperLogLog 中12PFADD nosqls redis memcached mongodbPFADD sqls mysql sqlserver pfcount：返回给定 HyperLogLog 的基数估算值1PFCOUNT nosqls pfmerge：将多个 HyperLogLog 合并为一个 HyperLogLog1PFMERGE dbs nosqls sqls 发布订阅subscribe：订阅给定的一个或多个频道的信息1SUBSCRIBE redisroom unsubscribe：退订给定的一个或多个频道的信息1UNSUBSCRIBE redisroom psubscribe：订阅一个或多个符合给定模式的频道1PSUBSCRIBE *chat punsubscribe：退订所有给定模式的频道1PUNSUBSCRIBE *chat publish：将信息发送到指定的频道1PUBLISH redisroom &quot;hello there&quot; pubsub：查看订阅与发布系统状态，三个参数可选CHANNELS，NUMSUB，NUMPAT 参数channels：返回当前活跃的频道，可指定pattern 参数numsub ：返回指定频道的订阅数，不包含模式订阅数 参数numpat ：返回通过模式订阅的频道数123PUBSUB CHANNELS *roomPUBSUB NUMSUB redisroomPUBSUB NUMPAT 事务介绍开启事务可以一次执行多个命令并且带有以下重要的保证 批量操作在发送 EXEC 命令前被放入队列缓存 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中一个事务从开始到执行会经历三个阶段：开始事务、命令入队、执行事务 multi：标记一个事务块的开始discard：取消事务，放弃执行事务块内的所有命令exec：执行所有事务块内的命令watch：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断unwatch：取消 WATCH 命令对所有 key 的监视12345678set a aaawatch a#unwatch（执行这个取消a监视）append a bbb （修改a的值）multi（开始事物）set b bbb#discard（执行这个取消事务）exec（返回nil，被打断，因为事务前a被修改） 安全设置密码可以通过 redis 的配置文件（redis.conf）或使用命令设置密码，这样客户端连接到 redis 服务就需要密码验证配置文件redis.conf：找到requirepass那行，将前面的注释去掉并修改密码，重启服务使用命令设置（重启无效，除非配置文件已经设置）：config set requirepass this_is_a_password使用命令清除：config set requirepass &quot;&quot;使用密码：auth this_is_a_password 数据备份与恢复save：在 redis安装目录中(/var/lib/redis)创建dump.rdb文件bgsave：在后台执行备份config get dir：获取redis安装目录恢复数据只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可 redis服务器命令SELECT [num]：切换数据库，默认数据库是0BGREWRITEAOF：异步执行一个 AOF（AppendOnly File） 文件重写操作BGSAVE：在后台异步保存当前数据库的数据到磁盘CLIENT KILL [ip:port] [ID client-id]：关闭客户端连接CLIENT LIST：获取连接到服务器的客户端连接列表CLIENT GETNAME：获取连接的名称CLIENT PAUSE timeout：在指定时间内终止运行来自客户端的命令CLIENT SETNAME connection-name：设置当前连接的名称CLUSTER SLOTS：获取集群节点的映射数组COMMAND：获取 Redis 命令详情数组COMMAND COUNT：获取 Redis 命令总数COMMAND GETKEYS：获取给定命令的所有键TIME：返回当前服务器时间COMMAND INFO command-name [command-name ...]：获取指定 Redis 命令描述的数组CONFIG GET parameter：获取指定配置参数的值CONFIG REWRITE：对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写CONFIG SET parameter value：修改 redis 配置参数，无需重启CONFIG RESETSTAT：重置 INFO 命令中的某些统计数据DBSIZE：返回当前数据库的 key 的数量DEBUG OBJECT key：获取 key 的调试信息DEBUG SEGFAULT：让 Redis 服务崩溃FLUSHALL：删除所有数据库的所有keyFLUSHDB：删除当前数据库的所有keyINFO [section]：获取 Redis 服务器的各种信息和统计数值LASTSAVE：返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示MONITOR：实时打印出 Redis 服务器接收到的命令，调试用ROLE：返回主从实例所属的角色SAVE：同步保存数据到硬盘SHUTDOWN [NOSAVE] [SAVE]：异步保存数据到硬盘，并关闭服务器SLAVEOF host port：将当前服务器转变为指定服务器的从属服务器(slave server)SLOWLOG subcommand [argument]：管理 redis 的慢日志SYNC：用于复制功能(replication)的内部命令","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://rainoceantop.github.io/Jesse/categories/NoSQL/"},{"name":"redis","slug":"NoSQL/redis","permalink":"https://rainoceantop.github.io/Jesse/categories/NoSQL/redis/"}],"tags":[{"name":"缓存技术","slug":"缓存技术","permalink":"https://rainoceantop.github.io/Jesse/tags/缓存技术/"},{"name":"缓存","slug":"缓存","permalink":"https://rainoceantop.github.io/Jesse/tags/缓存/"},{"name":"nosql","slug":"nosql","permalink":"https://rainoceantop.github.io/Jesse/tags/nosql/"},{"name":"redis","slug":"redis","permalink":"https://rainoceantop.github.io/Jesse/tags/redis/"},{"name":"非关系型数据库","slug":"非关系型数据库","permalink":"https://rainoceantop.github.io/Jesse/tags/非关系型数据库/"}]},{"title":"php魔法方法","slug":"php魔法方法","date":"2018-07-22T23:38:32.000Z","updated":"2018-07-22T23:47:58.361Z","comments":true,"path":"2018/07/23/php魔法方法/","link":"","permalink":"https://rainoceantop.github.io/Jesse/2018/07/23/php魔法方法/","excerpt":"本文列出php魔法方法什么情况下被调用（未完带续）","text":"本文列出php魔法方法什么情况下被调用（未完带续） construct：被实例化时调用123function __construct()&#123; echo &quot;被实例...&quot;;&#125; destruct：主动调用或者脚本结束或者使用exit()时调用123function __destruct()&#123; echo &quot;被释放...&quot;;&#125; call：调用一个不可访问或不存在的方法时被调用123function __call($name, $arguments)&#123; echo &quot;调用了一个不可访问的方法&quot;.$name.&quot;，参数：&quot;.implode(&quot;,&quot;,$arguments);&#125; callStatic：调用一个不可访问或不存在的静态方法时被调用123static function __callStatic($name, $arguments)&#123; echo &quot;调用了一个不可访问的静态方法&quot;.$name.&quot;，参数：&quot;.implode(&quot;,&quot;,$arguments);&#125; get：读取不可访问或不存在的属性时调用123function __get($name)&#123; echo $name.&quot;该属性不可获取&quot;;&#125; set：给不可访问或不存在的属性赋值时调用123function __set($name, $value)&#123; echo $name.&quot;该属性不可赋值&quot;.$value;&#125; isset：当对不可访问对象使用isset或empty时调用123function __isset($name)&#123; echo $name.&quot;正在使用isset&quot;;&#125; unset：当对不可访问对象使用unset时调用123function __unset($name)&#123; echo $name.&quot;正在使用unset&quot;;&#125; toString：当一个类被当成字符串打印时调用123function __toString()&#123; echo &quot;该类正在被打印&quot;;&#125;","categories":[{"name":"php","slug":"php","permalink":"https://rainoceantop.github.io/Jesse/categories/php/"},{"name":"魔法方法","slug":"php/魔法方法","permalink":"https://rainoceantop.github.io/Jesse/categories/php/魔法方法/"}],"tags":[{"name":"php","slug":"php","permalink":"https://rainoceantop.github.io/Jesse/tags/php/"},{"name":"魔法方法","slug":"魔法方法","permalink":"https://rainoceantop.github.io/Jesse/tags/魔法方法/"},{"name":"魔术方法","slug":"魔术方法","permalink":"https://rainoceantop.github.io/Jesse/tags/魔术方法/"}]},{"title":"分布式缓存系统memcached笔记","slug":"分布式缓存系统memcached笔记","date":"2018-07-22T22:57:00.000Z","updated":"2018-07-23T23:05:50.797Z","comments":true,"path":"2018/07/23/分布式缓存系统memcached笔记/","link":"","permalink":"https://rainoceantop.github.io/Jesse/2018/07/23/分布式缓存系统memcached笔记/","excerpt":"Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。","text":"Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。 安装向导linux安装memcached：sudo pacman -S memcached (manjaro) | sudo apt-get install memcached (ubuntu)启动/重启：memcached -m 64m -p 11211 -vv (common) | memcached | memcached start/stop/restart (ubuntu)查看运行状态：ps -ef|grep memcached查看帮助：memcached -htelnet连接：telnet localhost 11211 关键字stats：显示分析详情set：用于将 value(数据值) 存储在指定的 key(键) 中。如果set的key已经存在，则更新其值12set key flags exptime bytes [noreply] value add：用于将 value(数据值) 存储在指定的 key(键) 中。 如果 add 的 key 已经存在，则不会更新数据(过期的 key 会更新)12add key flags exptime bytes [noreply]value get：获取一个或多个存储在 key(键) 中的 value(数据值) ，如果 key 不存在，则返回空12get keyget key1 key2 key3 replace：用于替换已存在的 key(键) 的 value(数据值)。如果 key 不存在，则替换失败12replace key flags exptime bytes [noreply]value append：用于向已存在 key(键) 的 value(数据值) 后面追加数据12append key flags exptime bytes [noreply]value prepend：用于向已存在 key(键) 的 value(数据值) 前面追加数据12prepend key flags exptime bytes [noreply]value cas：（Check-And-Set 或 Compare-And-Swap） 命令用于执行一个”检查并设置”的操作，它需要指定当前key的cas_token才可以修改值，cas_token可以用gets获取到，每一次修改key值cas_token都会改变12cas key flags exptime bytes unique_cas_token [noreply]value delete：用于删除已存在的 key(键)1delete key [noreply] incr|decr：用于对已存在的 key(键) 的数字值进行自增或自减操作12incr key increment_valuedecr key decrement_value flush_all：用于清理缓存中的所有 key=&gt;value(键=&gt;值) 对1flush_all [time] [noreply] 语句参数解释key：键值 key-value 结构中的 key，用于查找缓存值 flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes：在缓存中存储的字节数 noreply（可选）： 该参数告知服务器不需要返回数据 value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） unique_cas_token：通过 gets命令获取的一个唯一的64位值 increment_value： 增加的数值 decrement_value： 减少的数值 time：用于在制定的时间后执行清理缓存操作","categories":[{"name":"缓存技术","slug":"缓存技术","permalink":"https://rainoceantop.github.io/Jesse/categories/缓存技术/"},{"name":"memcached","slug":"缓存技术/memcached","permalink":"https://rainoceantop.github.io/Jesse/categories/缓存技术/memcached/"}],"tags":[{"name":"memcached","slug":"memcached","permalink":"https://rainoceantop.github.io/Jesse/tags/memcached/"},{"name":"memcache","slug":"memcache","permalink":"https://rainoceantop.github.io/Jesse/tags/memcache/"},{"name":"缓存技术","slug":"缓存技术","permalink":"https://rainoceantop.github.io/Jesse/tags/缓存技术/"},{"name":"缓存","slug":"缓存","permalink":"https://rainoceantop.github.io/Jesse/tags/缓存/"}]},{"title":"mysql优化（配置参数优化）","slug":"mysql优化","date":"2018-07-09T17:55:39.000Z","updated":"2018-07-10T17:00:08.864Z","comments":true,"path":"2018/07/10/mysql优化/","link":"","permalink":"https://rainoceantop.github.io/Jesse/2018/07/10/mysql优化/","excerpt":"mysql优化主要分为三个方面1.内核优化（主要由服务器运维人员完成）2.配置参数优化（my.cnf），通过进行压力测试来适当调整配置参数3.SQL语句优化","text":"mysql优化主要分为三个方面1.内核优化（主要由服务器运维人员完成）2.配置参数优化（my.cnf），通过进行压力测试来适当调整配置参数3.SQL语句优化 前言：本文代码必须在mysql环境下实现命令行运行mysql命令：mysql -u 帐号 -p 密码 查看运行时间1.select version()：查看数据库版本，只有5.0.37以上版本才支持show profiles（查看语句具体运行时间）2.show variables like &quot;%pro%&quot;：查看profiling是否开启（默认不开启）3.set profiling = 1：开启profiling4.show profiles：查看所有运行过的sql语句的执行时间5.show profile for query 1：查看第一个sql语句执行过程的各个操作的耗时情况6.show profile cpu,block io,memory,swaps,context switches,source for query 1：查看第一个sql语句执行的各种资源消耗情况7.set profiling = 0：关闭profiling 修改变量大部分mysql变量都是可以用set加变量名修改的，具体有以下几种方式1.set profiling = 1/0：开启/关闭profiling，也可以使用2/3/4的命令2.set @@profiling = 1/0：效果如13.set @@session.profiling = 1/0：效果如14.set session profiling = 1/0：效果如1set global profiling = 1/0：由于profiling是当前会话级别的，所以该语句无效 查询变量查询变量可用show variables like &#39;%somthing%&#39;查询相关变量，如想查询指定变量可用select @@var_name1.GLOBAL：全局变量，修改这个级别的变量影响所有会话2.SESSION：当前会话变量，修改这个级别的变量影响当前会话3.SHOW [GLOBAL | SESSION] VARIABLES [LIKE &#39;pattern&#39; | WHERE expr]：查看变量（全局会话，当前会话）的通用表达式4.select @@global.var_name/@@session.var_name：查看单个变量（完全显示变量名和值） 自定义变量1.创建变量并赋值：set @name=&#39;hello world&#39;;2.变量赋值：set @name:=author from posts limit 0,1;（将查询到的author栏的第一个值赋值）3.查看变量：select @name; 缓存查看是否开启缓存show variables like &#39;%query_cache%&#39;：如果query_cache_type值是ON的话说明已经开启缓存查询得到的如下属性以及其代表意义 have_query_cache：表示当前版本mysql是否支持query cache query_cache_limit：指定单个查询能够使用的缓冲区大小，缺省为1M query_cache_min_res_unit：表示query cache每个结果集存放的最小内存大小，默认4k query_cache_size：表示系统中用于query cache的内存大小在Mysql中，可以设置Query Cache所使用的总内存,MySQL会把默认可以进行缓存的SQL语句的结果集进行缓存,一旦内存塞满后，就会剔除老的Query Cache对象。同时为了保证Query Cache中的内容与是实际数据绝对一致,当表中的数据有任何变化，包括新增、修改、删除等，都会使所有引用到该表的SQL的Query Cache 失效. query_cache_type：系统是否打开了query cache功能 123query_cache_type=0*（OFF）：关闭query_cache_type=1*（ON）：缓存所有结果，除非select语句使用SQL_NO_CACHE禁用查询缓存query_cache_type=2*(demand)：只缓存select语句中通过SQL_CACHE指定需要缓存的查询，例如 `select SQL_CACHE count(*) from table` query_cache_wlock_invalidate：针对myisam存储引擎，设置当有write lock在某个table上面的时候，读请求是要等待write lock释放资源之后再查询还是允许直接从query cache中读取结果，默认是OFF，可以直接从query cache中取得结果。 开启缓存打开配置文件（my.cnf），修改并保存以下内容123[mysqld]中添加query_cache_size = 20Mquery_cache_type = ON 缓存状态show status like &#39;qcache%&#39;：可查看缓存状态查询得到的如下属性以及其代表意义 Qcache_free_blocks：缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块 Qcache_free_memory：缓存中的空闲内存。 Qcache_hits：每次查询在缓存中命中时就增大 Qcache_inserts：表示未命中cache后将结果集再写入到cache中的次数 Qcache_lowmem_prunes：缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。这个数字最好长时间来看;如果这个 数字在不断增长，就表示可能碎片非常严重，或者内存很少。(上面的 free_blocks和free_memory可以告诉您属于哪种情况) Qcache_not_cached：不适合进行缓存的查询的数量，通常是由于这些查询不是SELECT语句或者用了now()之类的函数。 Qcache_queries_in_cache：当前缓存的查询(和响应)的数量 Qcache_total_blocks：缓存中块的数量 评估缓存命中率公式Qcache_hits/Com_select （缓存命中次数/总查询次数）当读写操作差不多的时候，建议关闭该功能，但是如果是大量查询,即读多写少的环境中，建议启用缓存注意，第一次查询时生成缓存，接下去的查询才会命中缓存查看Com_select（总查询次数）的总数MariaDB [sunny]&gt; show global status like &#39;Com%select%&#39;; 缓存数据失效时机 在表的结构或数据发生改变时，查询缓存中的数据不再有效 有这些INSERT、UPDATE、 DELETE、TRUNCATE、ALTER TABLE、DROP TABLE或DROP DATABASE会导致缓存数据失效所以查询缓存适合有大量相同查询的应用，不适合有大量数据更新的应用 清理查询缓存 FLUSH QUERY CACHE; // 清理查询缓存内存碎片 RESET QUERY CACHE; // 从查询缓存中移出所有查询 FLUSH TABLES; //关闭所有打开的表，同时该操作将会清空查询缓存中的内容 其他1.mysql配置文件：linux一般放在/etc/my.cnf（xampp集成环境在lampp下的etc中）2.查询mysql变量的单位：B（也就是如果你设置query_cache_size=20M，那么查询该变量时会显示20*1024*1024的值）3.如果使用的数据库引擎是innodb，那么innodb_buffer_pool_size是一个对于优化很重要的变量，可以缓存表的索引，数据，插入数据时的缓冲，值越大，可缓存的数据越多，就不需要频繁地进行磁盘I/O读写操作。如果是一个专用DB服务器，那么他可以占到内存的70%-80%。但是也不是越大越好，分配过大，会使Swap占用过多，致使Mysql的查询特慢","categories":[{"name":"mysql","slug":"mysql","permalink":"https://rainoceantop.github.io/Jesse/categories/mysql/"},{"name":"优化配置","slug":"mysql/优化配置","permalink":"https://rainoceantop.github.io/Jesse/categories/mysql/优化配置/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://rainoceantop.github.io/Jesse/tags/mysql/"},{"name":"mysql优化","slug":"mysql优化","permalink":"https://rainoceantop.github.io/Jesse/tags/mysql优化/"},{"name":"mysql优化配置","slug":"mysql优化配置","permalink":"https://rainoceantop.github.io/Jesse/tags/mysql优化配置/"}]},{"title":"linux下php集成环境配置","slug":"linux下php集成环境配置","date":"2018-06-17T23:02:54.000Z","updated":"2018-06-18T15:38:49.065Z","comments":true,"path":"2018/06/18/linux下php集成环境配置/","link":"","permalink":"https://rainoceantop.github.io/Jesse/2018/06/18/linux下php集成环境配置/","excerpt":"本文主要讲解linux下配置php集成环境。主要有以下内容： xampp的下载以及安装 apache以及mysql的启动与停止 修改配置文件","text":"本文主要讲解linux下配置php集成环境。主要有以下内容： xampp的下载以及安装 apache以及mysql的启动与停止 修改配置文件 xampp的下载与安装xampp可在官方网站的下载页下载，下载完打开下载目录，可以看到有一个名类似为xampp-linux-x64-xxxxx-x-installer.run的安装文件。打开终端命令行，键入以下代码进行安装1234//首先进入到xampp安装文件的目录，我的是下载目录cd 下载//然后运行安装文件启动安装程序，一般情况下一直点击next即可，xampp一般情况下会被安装在/opt目录下的lamppsudo ./xampp-linux-x64-xxxxx-x-installer.run apache以及mysql命令行启动停止操作（推荐）123sudo /opt/lampp/lampp start //启动服务sudo /opt/lampp/lampp restart //重启服务sudo /opt/lampp/lampp stop //停止服务 图形管理界面操作1sudo /opt/lampp/manager-linux-x64.run //打开图形管理界面 图形管理界面 启动服务后建议打开浏览器输入localhost网址看下有没有运行成功 修改apache默认执行路径apache的默认执行路径是项目文件夹的htdocs目录，因为xampp是安装在linux根目录的opt文件夹下面，由于权限问题是不能创建文件以及文件夹的。为了方便操作，我们可以把他的执行路径更改到可方便操作的地方，比如用户下面(/home/user/)。xampp的配置文件放在该目录的etc文件夹中，由于权限问题，如果要更改执行路径可以用命令行通过nano操作123456789//通过nano打开apache配置文件，注意要用sudo管理员身份打开sudo nano /opt/lampp/etc/httpd.conf//找到下面两行，将路径改为你的项目路径DocumentRoot \"/home/user/yourapp\"&lt;Directory \"/home/user/yourapp\"&gt;//打开apache下的config文件sudo nano /opt/lampp/apache2/conf/httpd.conf//继续修改路径&lt;Directory \"/home/user/yourapp\"&gt; 修改完后按ctrl o保存，ctrl x退出编辑，然后输入sudo /opt/lampp/lampp restart重启apache服务器 其他mysql操作因为xampp自带phpmyadmin，我们可以很方便的查看以及操作数据库。在打开了apache以及mysql服务后，在浏览器输入localhost/phpmyadmin即可进入数据库图形操作界面（自动登录）。值得注意的是，phpmyadmin默认的帐号是root，密码为空，也就是””，与mysql相同（可以打开/opt/lampp/phpmyadmin/config.inc.php查看）。如果要连接mysql数据库，使用帐号root密码&quot;&quot;连接即可。 php解释器路径xampp的php解释器默认情况下放在/opt/lampp/bin/php，可以在命令行键入whereis php查看","categories":[{"name":"linux","slug":"linux","permalink":"https://rainoceantop.github.io/Jesse/categories/linux/"},{"name":"php","slug":"linux/php","permalink":"https://rainoceantop.github.io/Jesse/categories/linux/php/"},{"name":"环境配置","slug":"linux/php/环境配置","permalink":"https://rainoceantop.github.io/Jesse/categories/linux/php/环境配置/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://rainoceantop.github.io/Jesse/tags/linux/"},{"name":"php","slug":"php","permalink":"https://rainoceantop.github.io/Jesse/tags/php/"},{"name":"php集成环境配置","slug":"php集成环境配置","permalink":"https://rainoceantop.github.io/Jesse/tags/php集成环境配置/"}]},{"title":"manjaro基本设置","slug":"manjaro基本设置","date":"2018-06-04T23:11:33.000Z","updated":"2018-06-05T00:38:23.738Z","comments":true,"path":"2018/06/05/manjaro基本设置/","link":"","permalink":"https://rainoceantop.github.io/Jesse/2018/06/05/manjaro基本设置/","excerpt":"Manjaro是一款基于Arch Linux、对用户友好、全球排名第1的Linux发行版。详情参见distrowatch这篇文章主要是将manjaro刚安装完需要设置的东西罗列出来，一切都是为了在使用中尽量减少碰见的问题附上manjaro的相关链接：manjaro中文网manjaro官方网站manjaro安装参考","text":"Manjaro是一款基于Arch Linux、对用户友好、全球排名第1的Linux发行版。详情参见distrowatch这篇文章主要是将manjaro刚安装完需要设置的东西罗列出来，一切都是为了在使用中尽量减少碰见的问题附上manjaro的相关链接：manjaro中文网manjaro官方网站manjaro安装参考 配置国内源打开manjaro命令行（菜单里的终端模拟器），键入如下两行代码12345//由于各方面原因，有些命令可能不起作用，前三行代码逐个测试，可以之后跳到更新系统sudo pacman-mirrors -gb testing -c China //选择中国源，可选一个或多个或全选sudo pacman-mirrors -b testing -c Chinasudo pacman-mirrors -i -c China -m ranksudo pacman -Syyu //更新系统 升级软件由于配置了中国源，现在就不受网速限制了。看到右下角的软件包管理器提醒你更新软件了吗？打开它并更新软件至最新版本 配置输入法在软件管理包搜索并下载谷歌拼音，通过软件包管理器下载输入法会同时下载相关依赖，如fcitx。下载完重启才能开启输入法（至少目前我不知道还有其他方法）如果发现不能配置输入法，打开命令行键入以下命令后再重试12sudo pacman -S fcitx-imsudo pacman -S fcitx-configtool 在配置界面里可以配置输入法的切换激活快捷键，但还差最后一步配置才能正常使用输入法打开命令行，键入以下代码123456sudo nano ~/.xprofile //进入编辑页面后，复制以下代码粘贴上去，然后根据提示保存后离开重试#fcitxexport GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=\"@im=fcitx\" 时间调整如果你使用的是双系统（manjaro和windows并存），那么你可能会遇到时间比你所在时区的正常时间快了8个小时。这是因为linux和windows看待系统硬件的方式是不一样的Windows把系统硬件时间当作本地时间(local time),即操作系统中显示的时间跟BIOS中显示的时间是一样的。 Linux/Unix/Mac把硬件时间当作UTC，操作系统中显示的时间是硬件时间经过换算得来的，比如说北京时间是GMT+8，则系统中显示时间是硬件时间+8。解决方法其实也很简单，只要进入windows系统。通过右击时间显示区，打开日期和时间，修改时区为(UTC)协调世界时即可 win10系统下关机后自动重启进入电源选项（控制面板或左下角搜索栏搜索电源）→选择电源按钮的功能→更改当前不可用的设置→取消勾选“启用快速启动”功能 即可 添加archlinuxCN源打开命令行，键入以下代码12345678910sudo nano /etc/pacman.conf//进入编辑页面后，在文件底部加入如下几行，保存离开[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch//配置完后键入以下命令sudo pacman-mirrors -g //更新并选择最快的源列表pacman -S archlinux-keying //更新archlinux签名sudo pacman -S yaourt //用于软件安装arch源的软件sudo pacman -Syyu //同步并更新系统 安装常用软件如果已经安装了archlinuxcn源，可以打开软件包管理器-&gt;首选项-&gt;AUR-&gt;启用AUR支持，然后就可以直接在管理器里下载需要的软件了或者也可以使用命令行安装，以下列出两个例子 网易云音乐1sudo yaourt -S netease-cloud-music 微信1sudo yaourt -S electronic-wechat","categories":[{"name":"linux","slug":"linux","permalink":"https://rainoceantop.github.io/Jesse/categories/linux/"},{"name":"manjaro","slug":"linux/manjaro","permalink":"https://rainoceantop.github.io/Jesse/categories/linux/manjaro/"},{"name":"基本设置","slug":"linux/manjaro/基本设置","permalink":"https://rainoceantop.github.io/Jesse/categories/linux/manjaro/基本设置/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://rainoceantop.github.io/Jesse/tags/linux/"},{"name":"archlinux","slug":"archlinux","permalink":"https://rainoceantop.github.io/Jesse/tags/archlinux/"},{"name":"manjaro","slug":"manjaro","permalink":"https://rainoceantop.github.io/Jesse/tags/manjaro/"},{"name":"manjaro基本设置","slug":"manjaro基本设置","permalink":"https://rainoceantop.github.io/Jesse/tags/manjaro基本设置/"}]},{"title":"linux基础","slug":"linux基础","date":"2018-06-04T21:59:02.000Z","updated":"2018-07-22T23:33:13.957Z","comments":true,"path":"2018/06/05/linux基础/","link":"","permalink":"https://rainoceantop.github.io/Jesse/2018/06/05/linux基础/","excerpt":"Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。开发者：Linus Torvalds（同时也是git的开发者） Linux吉祥物 Tux","text":"Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。开发者：Linus Torvalds（同时也是git的开发者） Linux吉祥物 Tux 目录操作进入目录：cd mulu/mulu2 返回目录：cd ../.. 返回最上层目录：cd - 返回home : cd ~ 绝对路径进入目录：cd /home/jesse/Documents/folder 文件操作创建创建文件：touch file1.txt file2 file3 创建文件夹：mkdir folder3 删除删除文件夹：rmdir folder3(删除空文件夹) 删除文件/文件夹： rm file1 rm -r folder1/(递归逐个删除) rm -i file1 file2 file3 file4(逐个提示是否删除) rm -I file1 file2 file3 file4(大于三个文件时提示是否删除) rm *(清空该目录下所有文件) rm /(清空系统所有文件) 复制&amp;剪切复制文件： cp file1 filecopy(如果存在会覆盖) cp -i file1 filecopy(如果存在会提示) cp file1 folder/(复制到文件夹folder中，/识别文件夹) cp -R folder/ folder2/(-R代表递归，逐个将folder的文件复制到folder2中) cp file* folder2/(将所有file开头的文件复制到folder2目录下) cp *file folder2/(将所有file结尾的文件复制到folder2目录下) cp file1 file2 file3 folder2/(将前面所有的东西复制到最后所指的目录) 剪切： mv file1 folder/ (移动到当前文件夹的folader文件夹下) mv file1 ./folder (同上，移动到当前文件夹的folader文件夹下) mv file1 ./folder file2 (移动到当前文件夹的folader文件夹下并重命名为file2) mv file1 /folder (!此操作会将文件移动到根目录) 查看查看当前目录下的文件列表：ls 查看当前目录下的文件列表的详细信息：ls -l 或者 ls -lh(适合人类看的) 查看当前目录下的所有文件列表：ls -a 查看ls的所有功能：ls --help nano编辑文件(功能命令^代表ctrl键)：nano t.py(不存在文件的话会自动创建文件) cat编辑文件： cat t.py(显示文件内容) cat t.py &gt; t1.py(将t.py的内容复制到t1.py中) cat t.py t1.py &gt; t2.py(将t.py t1.py的内容复制到t2.py中) cat t3.py &gt;&gt; t2.py(将t3.py的内容加到t2.ty的后面) 执行运行python3文件：python3 t.py（被执行文件头部需要有解释器声明 #!/usr/bin/python3） 权限操作权限解读第1代表类型，第2-4代表user，第5-7代表group，第8-10代表其他的权限，例如： drwxr-xr-x：d代表文件夹类型，r代表可读，w代表可写，x代表可执行(执行命令：./t1.py) -rw-r--r--：第一个-代表文件类型 修改权限chmod u+r t1.py(为user用户t1.py增加可读权限) chmod u+rwx t1.py(为user用户t1.py增加可读可写可执行权限) chmod u-r t1.py(为user用户t1.py减去可读权限) chmod g+r t1.py(为group用户t1.py增加可读权限) chmod o+r t1.py(为others用户t1.py增加可读权限) chmod a+r t1.py(为全部用户t1.py增加可读权限) chmod ug+r t1.py(为user,group用户t1.py增加可读权限) SSH连接下载linux SSH终端：sudo apt-get install openssh-server 获取ip地址：ifconfig(如果提示没安装一些东西：sudo apt install net-tools) 用mac控制linux：ssh jesse@192.168.0.108 用windows控制：下载PuTTY 手机控制：下载ssh应用 控制后图形界面显示： 使用外网 Teamviewer 使用局域网 VNC(sudo apt-get install x11vnc) mac将文件推送到linux运行：ssh jesse@192.168.0.108 python3 &lt; t1.py(将t1.py推送到linux上运行) 将文件复制到linux上：scp {a,b}.py jesse@192.168.0.108:~/Desktop/ 从linux云端保存到本地：scp jesse@192.168.0.108:~/Desktop/b.py c.py 控制云端弹出窗口：ssh jesse@192.168.0.108 &quot;export DISPLAY:0; firefox&quot; 其他清空命令行：clear 下载软件：sudo apt-get install xxxxx （arch系列的linux不适用） sudo pacman -S xxxxx (manjaro)","categories":[{"name":"linux","slug":"linux","permalink":"https://rainoceantop.github.io/Jesse/categories/linux/"},{"name":"基础","slug":"linux/基础","permalink":"https://rainoceantop.github.io/Jesse/categories/linux/基础/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://rainoceantop.github.io/Jesse/tags/linux/"},{"name":"linux基础","slug":"linux基础","permalink":"https://rainoceantop.github.io/Jesse/tags/linux基础/"},{"name":"linux基本指令","slug":"linux基本指令","permalink":"https://rainoceantop.github.io/Jesse/tags/linux基本指令/"}]},{"title":"git的基本命令","slug":"git的基本命令","date":"2018-06-04T21:02:42.000Z","updated":"2018-06-04T22:42:42.448Z","comments":true,"path":"2018/06/05/git的基本命令/","link":"","permalink":"https://rainoceantop.github.io/Jesse/2018/06/05/git的基本命令/","excerpt":"Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。开发者：Linus Torvalds（同时也是linux的开发者，他是神↓） Linus Torvalds","text":"Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。开发者：Linus Torvalds（同时也是linux的开发者，他是神↓） Linus Torvalds 身份象征确定身份象征(提交任何修改使用)12git config --global user.name \"\"git config --global user.email \"\" 查看身份象征12git config user.namegit config user.email 操作项目确定管理项目cd进入到该项目目录 初始化git init 查看管理库状态 查看普通状态git status查看修改状态git status -s 添加可提交修改（commited）文件（stage状态的文件） 提交单个文件git add 1.py提交所有文件git add .撤销提交的文件git reset 1.py 提交文件 直接提交git commit -m &quot;提交信息&quot;直接提交并添加git commit -am &quot;提交信息&quot;（已经管理库有的文件，新文件无法识别到）提交文件至上次提交的分支git commit --amend（上次分支） --no-edit（不修改-m信息） 打印git日志 直接打印git log简洁打印git log --oneline简洁图形打印git log --oneline --graph 查看修改信息 查看已修改未添加的修改信息git diff查看已添加的修改信息git diff --cached查看已添加再修改文件的修改信息git diff HEAD 修改当前的头分支git reset --hard (分支id号或HEAD指针（HEAD@{0}）) 重置单个文件的内容信息git checkout 分支id号 -- 1.py 暂存任务 暂存当前任务git stash取出暂存任务git stash pop 分支操作 创建分支git branch dev 或者 git checkout -b dev(创建并切换到该分支)查看分支git branch切换分支git checkout dev删除分支git branch -d dev合并分支git merge --no-ff -m &quot;合并信息&quot; dev合并分支git rebase dev git工作流程图 git工作流程图 github建立远程连接git remote add origin xxxxxxxxxx.git 从远程取分支的更新并与本地指定分支结合git pull origin remotebranch:localbranch 远程分支的更新与当前分支结合git pull origin remotebranch 将本地分支上传到远程分支git push -u origin master 将本地分支强制上传到远程分支git push -fu origin master（覆盖掉远程分支的所有文件）","categories":[{"name":"git","slug":"git","permalink":"https://rainoceantop.github.io/Jesse/categories/git/"},{"name":"基本命令","slug":"git/基本命令","permalink":"https://rainoceantop.github.io/Jesse/categories/git/基本命令/"}],"tags":[{"name":"git","slug":"git","permalink":"https://rainoceantop.github.io/Jesse/tags/git/"},{"name":"git基本命令","slug":"git基本命令","permalink":"https://rainoceantop.github.io/Jesse/tags/git基本命令/"},{"name":"git基础","slug":"git基础","permalink":"https://rainoceantop.github.io/Jesse/tags/git基础/"}]}]}